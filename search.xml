<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/21/hello-world/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#quick-start">Quick Start</a><ul>
<li><a href="#create-a-new-post">Create a new post</a></li>
<li><a href="#run-server">Run server</a></li>
<li><a href="#generate-static-files">Generate static files</a></li>
<li><a href="#deploy-to-remote-sites">Deploy to remote sites</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="note default"><p>这里输入文字<br/>这里输入文字</p></div>
<div class="note success"><p>这里输入文字</p></div>
<div class="note primary"><p>这里输入文字</p></div>
<div class="note info"><p>这里输入文字</p></div>
<div class="note warning"><p>这里输入文字</p></div>
<div class="note danger"><p>这里输入文字</p></div>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p><span id="inline-red"> 这里输入文字 </span><br><span id="inline-blue"> 这里输入文字 </span><br><span id="inline-purple"> 这里输入文字 </span><br><span id="inline-yellow"> 这里输入文字 </span><br><span id="inline-green"> 这里输入文字 </span><br><span id="inline-toc">这里输入文字</span></p>
<p><span id="inline-toc">1.</span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p><a id="download" href="/download/model_infer.py"><i class="fas fa-book-reader"></i><span> 查看内容</span></a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span>  <span class="attr">src</span> =<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><blockquote class="blockquote-center">
<p>Szabadság，Szerelem!<br>E kettő kell nekem<br>Szerelmemért föláldozom<br>Az életet<br>Szabadságért föláldozom<br>Szerelmemet.</p>

</blockquote>
]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-2 编译过程</title>
    <url>/2022/07/21/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-2%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="linux-应用开发-2-编译过程"><a href="#linux-应用开发-2-编译过程" class="headerlink" title="linux 应用开发-2 编译过程"></a><div align = "center">linux 应用开发-2 编译过程</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-2-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bdiv"><div align = "center">linux 应用开发-2 编译过程</div></a><ul>
<li><a href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B">编译流程</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E6%8B%93%E5%B1%95">编译拓展</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><pre class="mermaid">flowchart LR
    Main.c-- 预编译 -->Main.i
    Main.i-- 编译 -->Main.s
    Main.s-- 汇编 -->Main.o
    Main.o --链接-->led.elf
    start.s -- 汇编 -->start.o
    start.o -- 链接 -->led.elf
    led.elf -- 反汇编 -->led.dis</pre>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cc1 xx<span class="selector-class">.c</span> =&gt; xx<span class="selector-class">.s</span>                  其中涉及预编译--查找头文件、展开宏；编译</span><br><span class="line">as xx<span class="selector-class">.s</span> =&gt; xx<span class="selector-class">.o</span>                   汇编</span><br><span class="line">collect2 xx<span class="selector-class">.o</span> xx<span class="selector-class">.so</span> ... =&gt; APP    链接</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gcc -E -o hello<span class="selector-class">.i</span> hello<span class="selector-class">.c</span>   预处理</span><br><span class="line">gcc -S -o hello<span class="selector-class">.s</span> hello<span class="selector-class">.i</span>   编译</span><br><span class="line">gcc -c -o hello<span class="selector-class">.o</span> hello<span class="selector-class">.s</span>   汇编</span><br><span class="line">gcc -o hello hello<span class="selector-class">.o</span>        链接</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="编译拓展"><a href="#编译拓展" class="headerlink" title="编译拓展"></a>编译拓展</h2><div class="note danger"><p>include头文件<>会到工具链指定路径下查找</p></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello<span class="selector-class">.c</span> -<span class="selector-tag">I</span> ./  -<span class="selector-tag">I</span>可以手动添加头文件路径，编译时就会到指定目录下查找</span><br></pre></td></tr></table></figure>

<p><span id="inline-red"> 或者将头文件生成静态库 </span><br><a id="download" href="/download/model_infer.py"><i class="fas fa-file-download"></i><span> <font color="blue">下载内容</font></span></a></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gcc -c -o <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">main</span><span class="selector-class">.s</span></span><br><span class="line">gcc -c -o sub<span class="selector-class">.o</span> sub<span class="selector-class">.s</span></span><br><span class="line">ar crs libsub<span class="selector-class">.a</span> sub<span class="selector-class">.o</span> xx<span class="selector-class">.o</span>(可以使用多个xx.o生成静态库)</span><br><span class="line">gcc -o test <span class="selector-tag">main</span><span class="selector-class">.o</span> libsub<span class="selector-class">.a</span>(如果.a不在当前路径下，需要指定绝对或相对路径)</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
<p>运行不需要把静态库放到板子上<br>&#x3D;&#x3D;交叉编译&#x3D;&#x3D;需要最后加上<code>-fPIC</code>参数</p>

</blockquote>

<p>动态库的生成</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gcc -c -o <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">main</span><span class="selector-class">.s</span></span><br><span class="line">gcc -c -o sub<span class="selector-class">.o</span> sub<span class="selector-class">.s</span></span><br><span class="line">gcc -shared -o libsub<span class="selector-class">.so</span> sub<span class="selector-class">.o</span> xx<span class="selector-class">.o</span></span><br><span class="line">gcc -o test <span class="selector-tag">main</span><span class="selector-class">.o</span> -lsub -L /libsub.so/所在目录     （-lsub     省略了lib 及.so）</span><br></pre></td></tr></table></figure>

<p>因为使用动态库链接，编译时还是会到工具链指定目录下寻找，所以把动态库放在工具链目录下或者就使用<code>-L</code>指定动态库目录，<code>export LD_LIBRARY = $LD_LIBRARY_PATH:./</code></p>
<blockquote>
<p>静态库与动态库的区别</p>
<blockquote>
<p>静态库文件比动态库更大<br>静态文件更适合移植</p>
<blockquote>
<p><code>echo &#39;main()&#123;&#125;&#39;| gcc -E -v -</code>列出头文件，库文件目录</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-1 交叉编译</title>
    <url>/2022/07/21/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-1%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="linux-应用开发-1-交叉编译"><a href="#linux-应用开发-1-交叉编译" class="headerlink" title="linux 应用开发-1 交叉编译"></a><div align = "center">linux 应用开发-1 交叉编译</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-1-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91div"><div align = "center">linux 应用开发-1 交叉编译</div></a><ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F-helloworld">第一个程序-hello，world！</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%8A%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8">编译器及交叉编译器</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<span id="more"></span>

<h2 id="第一个程序-hello，world！"><a href="#第一个程序-hello，world！" class="headerlink" title="第一个程序-hello，world！"></a>第一个程序-hello，world！</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO, %s!\n&quot;</span>argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO,WORLD!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>argc</code>是参数的个数，<code>argv</code>是参数</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">./hello xiudi xiuxiuxiu</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] <span class="operator">=</span> ./hello</span><br><span class="line">argv[<span class="number">1</span>] <span class="operator">=</span> <span class="string">&quot;xiudi&quot;</span></span><br><span class="line">argv[<span class="number">2</span>] <span class="operator">=</span> <span class="string">&quot;xiuxiuxiu&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="编译器及交叉编译器"><a href="#编译器及交叉编译器" class="headerlink" title="编译器及交叉编译器"></a>编译器及交叉编译器</h2><p>linux 上常用编译器<code>==gcc==</code>编译器及<code>arm</code>编译器<br><code>gcc</code>将<code>.c</code>文件编译成<code>X86</code>的文件形式<br><code>arm</code>则编译成<code>arm</code>架构</p>
<div align=center><img  src ="https://pic.imgdb.cn/item/62da6f7cf54cd3f937200913.png"/></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62da6f31f54cd3f9371eaa6f.png"/></div>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">arm-linux-gnueabihf-gcc <span class="selector-tag">main</span><span class="selector-class">.o</span> lcd<span class="selector-class">.o</span> -o main</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;gaoliang&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-3Makefile规则</title>
    <url>/2022/07/23/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-3Makefile%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="linux-应用开发-3Makefile-规则"><a href="#linux-应用开发-3Makefile-规则" class="headerlink" title="linux 应用开发-3Makefile 规则"></a><div align = "center">linux 应用开发-3Makefile 规则</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-3makefile-%E8%A7%84%E5%88%99div"><div align = "center">linux 应用开发-3Makefile 规则</div></a><ul>
<li><a href="#makefile-%E4%BD%9C%E7%94%A8">Makefile 作用</a></li>
<li><a href="#makefile-%E8%A7%84%E5%88%99">Makefile 规则</a></li>
<li><a href="#makefile-%E8%AF%AD%E6%B3%95">Makefile 语法</a></li>
<li><a href="#makefile-%E5%87%BD%E6%95%B0">Makefile 函数</a></li>
<li><a href="#makefile-%E5%AE%9E%E4%BE%8B">Makefile 实例</a></li>
<li><a href="#%E9%80%9A%E7%94%A8-makefile">通用 Makefile</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="Makefile-作用"><a href="#Makefile-作用" class="headerlink" title="Makefile 作用"></a>Makefile 作用</h2><p>makefile 就是对文件分别编译,最后链接在一起,避免全部文件都编译一次</p>
<h2 id="Makefile-规则"><a href="#Makefile-规则" class="headerlink" title="Makefile 规则"></a>Makefile 规则</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">规则</span><br><span class="line">目标文件:依赖<span class="number">1</span> 依赖<span class="number">2</span> ...</span><br><span class="line">[<span class="symbol">Tab</span>] 命令</span><br></pre></td></tr></table></figure>

<div class="note success"><p>目标文件不存在</p></div>
<div class="note success"><p>当"依赖"比"目标"新,执行命令</p></div>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">test:<span class="selector-tag">a</span><span class="selector-class">.o</span> <span class="selector-tag">b</span><span class="selector-class">.o</span></span><br><span class="line">    gcc -o test <span class="selector-tag">a</span><span class="selector-class">.o</span> <span class="selector-tag">b</span><span class="selector-class">.o</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.o</span>:<span class="selector-tag">a</span><span class="selector-class">.c</span></span><br><span class="line">    gcc -c -o <span class="selector-tag">a</span><span class="selector-class">.o</span> <span class="selector-tag">a</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.o</span>:<span class="selector-tag">b</span><span class="selector-class">.c</span></span><br><span class="line">    gcc -c -o <span class="selector-tag">b</span><span class="selector-class">.o</span> <span class="selector-tag">b</span>.c</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">:=  #即时变量</span><br><span class="line"><span class="section">=   #延时变量</span></span><br><span class="line">?=  #延时变量,如果是第一次定义才起效,如果在前面该变量已定义则忽略这句</span><br><span class="line">+=  #附加,它是即时变量,还是延时变量取决于前面的定义</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
<blockquote>
<p>即时变量,延时变量,export</p>
<blockquote>
<p>A :&#x3D; xxx #A 的值即刻确定,在定义时即确定<br>B &#x3D; xxx #B 的值使用到时才确定</p>
<blockquote>
<p>即时就是当前赋值,延时就是全局生效,之前的变量也会跟着改变</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>通配符: %.o</p>
<blockquote>
<p>$@ 表示目标<br>$&lt; 表示第 1 个依赖文件<br>$^ 表示所有依赖文件</p>
</blockquote>
</blockquote>
<blockquote>
<p>假象目标: .PHONY</p>
<blockquote>
<p>.PHONY: clean 假想 clean 文件,就算存在 clean 文件,也能执行 clean 命令</p>
</blockquote>
</blockquote>

</blockquote>

<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test: </span>a.o b.o ...</span><br><span class="line">    gcc -o test a.o b.o ...</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">    gcc -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm *.o test</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-函数"><a href="#Makefile-函数" class="headerlink" title="Makefile 函数"></a>Makefile 函数</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">foreach</span> <span class="params">var</span>, <span class="params">list</span>, <span class="params">text</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">$(<span class="params">filter</span> <span class="params">pattern</span><span class="operator">...</span>, <span class="params">text</span>)</span>      #在text中取出符合pattern格式的值</span><br><span class="line"><span class="constructor">$(<span class="params">filter</span>-<span class="params">out</span> <span class="params">pattern</span><span class="operator">...</span>, <span class="params">text</span>)</span>  #在text中取出不符合pattern格式的值</span><br><span class="line"></span><br><span class="line"><span class="constructor">$(<span class="params">wildcard</span> <span class="params">pattern</span>)</span>             #patttern定义了文件名的格式</span><br><span class="line">                                #wildcard取出其中存在的格式</span><br><span class="line"></span><br><span class="line"><span class="constructor">$(<span class="params">parsubst</span> <span class="params">pattern</span>, <span class="params">replacement</span>, $(<span class="params">var</span>)</span>)</span><br><span class="line">                                #从var中取出每个值,符合pattern格式的,替换成replacement格式</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dbc7bef54cd3f9374f0169.jpg"/></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dbc824f54cd3f937516fca.jpg"/></div>

<h2 id="Makefile-实例"><a href="#Makefile-实例" class="headerlink" title="Makefile 实例"></a>Makefile 实例</h2><div class="note success"><p>当我们更新.h文件里的宏定义时,make并不会更新,因为Makefile里并没有联系起来</p></div>

<p>.c 文件里,这么多.h 文件,我们要怎么才能将这么多.h 文件全部联系起来呢?</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">gcc -M c.c                      <span class="meta">#打印出依赖</span></span><br><span class="line"></span><br><span class="line">gcc -M -MF c.d c.c              <span class="meta">#把依赖写入c.d</span></span><br><span class="line"></span><br><span class="line">gcc -c -o c.o c.c -MD -MF c.d   <span class="meta">#编译c.o,把依赖写入文件c.d</span></span><br><span class="line"></span><br><span class="line">CFLAGS                          <span class="meta">#gcc编译器选项</span></span><br><span class="line">                                <span class="meta">#-g：生成调试信息</span></span><br><span class="line">                                <span class="meta">#-Wall：输出全部的告警信息</span></span><br><span class="line">                                <span class="meta">#-I./<span class="keyword">include</span>：添加头文件搜索目录./<span class="keyword">include</span></span></span><br><span class="line">                                <span class="meta">#-I./<span class="keyword">include</span>/tinyalsa：添加头文件搜索目录./<span class="keyword">include</span>/tinyalsa</span></span><br><span class="line">                                <span class="meta">#-Wl,--whole-archive -lpthread：将libpthread.so及以后的库中的所有符号都链接进可执行目标文件</span></span><br><span class="line">                                <span class="meta">#-Wl,--no-whole-archive：关闭之前的-Wl,--whole-archive -lpthread 选项</span></span><br><span class="line">                                <span class="meta">#LDFLAGS = -L./lib，将makefile当前目录下的、lib文件夹添加到库文件搜索目录</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objs = a.o b.o c.o ...</span><br><span class="line"></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">patsubst</span> %, .%.d, <span class="variable">$(objs)</span>)</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line">CFLAGS = -Werror -I.</span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(objs)</span></span></span><br><span class="line">    gcc -o test <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> -MD -MF .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test</span><br><span class="line"></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">    rm <span class="variable">$(dep_files)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br></pre></td></tr></table></figure>

<h2 id="通用-Makefile"><a href="#通用-Makefile" class="headerlink" title="通用 Makefile"></a>通用 Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CROSS_COMPILE =</span><br><span class="line">AS		= <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD		= <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC		= <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP		= <span class="variable">$(CC)</span> -E</span><br><span class="line">AR		= <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM		= <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line"></span><br><span class="line">STRIP		= <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY		= <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP		= <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> AS LD CC CPP AR NM</span><br><span class="line"><span class="keyword">export</span> STRIP OBJCOPY OBJDUMP</span><br><span class="line"></span><br><span class="line">CFLAGS := -Wall -O2 -g</span><br><span class="line">CFLAGS += -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">LDFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="keyword">export</span> TOPDIR</span><br><span class="line"></span><br><span class="line">TARGET := test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj-y += main.o //需要修改为自己的</span><br><span class="line">obj-y += sub.o</span><br><span class="line">obj-y += a/     //修改为自己的子目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all : start_recursive_build <span class="variable">$(TARGET)</span></span><br><span class="line">	@echo <span class="variable">$(TARGET)</span> has been built!</span><br><span class="line"></span><br><span class="line"><span class="section">start_recursive_build:</span></span><br><span class="line">	make -C ./ -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : built-in.o</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> built-in.o <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.d&quot;)</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY := __build</span><br><span class="line"><span class="section">__build:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj-y :=</span><br><span class="line">subdir-y :=</span><br><span class="line">EXTRA_CFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># obj-y := a.o b.o c/ d/</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y))   : c/ d/</span></span><br><span class="line"><span class="comment"># __subdir-y  : c d</span></span><br><span class="line"><span class="comment"># subdir-y    : c d</span></span><br><span class="line">__subdir-y	:= <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y	+= $(__subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># c/built-in.o d/built-in.o</span></span><br><span class="line">subdir_objs := <span class="variable">$(<span class="built_in">foreach</span> f,$(subdir-y)</span>,<span class="variable">$(f)</span>/built-in.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o b.o</span></span><br><span class="line">cur_objs := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>)</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(cur_objs)</span>,.<span class="variable">$(f)</span>.d)</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PHONY += $(subdir-y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__build : $(subdir-y) built-in.o</span><br><span class="line"></span><br><span class="line"><span class="section">$(subdir-y):</span></span><br><span class="line">	make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">	<span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">dep_file = .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(EXTRA_CFLAGS)</span> $(CFLAGS_<span class="variable">$@</span>) -Wp,-MD,<span class="variable">$(dep_file)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">.PHONY : <span class="variable">$(PHONY)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXTRA_CFLAGS </span>:= -D <span class="built_in">DEBUG</span>            <span class="comment">#-D 宏定义一个参数</span></span><br><span class="line">CFLAGS_sub3.o := -D DEBUG_SUB3</span><br><span class="line"></span><br><span class="line">obj-y += <span class="keyword">sub2.o </span>                    <span class="comment">#自己的文件</span></span><br><span class="line">obj-y += <span class="keyword">sub3.o</span></span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dbe11ef54cd3f937e0dfe3.jpg"/></div>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-5LCDframebuffer</title>
    <url>/2022/07/24/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-5LCDframebuffer/</url>
    <content><![CDATA[<h1 id="linux-应用开发-5LCDframebuffer"><a href="#linux-应用开发-5LCDframebuffer" class="headerlink" title="linux 应用开发-5LCDframebuffer"></a><div align = "center">linux 应用开发-5LCDframebuffer</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-5lcdframebufferdiv"><div align = "center">linux 应用开发-5LCDframebuffer</div></a><ul>
<li><a href="#lcd-%E5%8E%9F%E7%90%86">LCD 原理</a></li>
<li><a href="#lcd-%E4%BB%A3%E7%A0%81">LCD 代码</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="LCD-原理"><a href="#LCD-原理" class="headerlink" title="LCD 原理"></a>LCD 原理</h2><div class="note success"><p>当使用LCD时需要知道LCD的分辨率,和像素点的位数(bpp)</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dd1575f54cd3f937866eef.jpg"/></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dd16a7f54cd3f9378df41e.jpg"/></div>

<h2 id="LCD-代码"><a href="#LCD-代码" class="headerlink" title="LCD 代码"></a>LCD 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_fb;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">fb_var_screeninfo</span> var;	<span class="comment">/* Current var */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> screen_size;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> line_width;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> pixel_width;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * 函数名称： lcd_put_pixel</span></span><br><span class="line"><span class="comment"> * 功能描述： 在LCD指定位置上输出指定颜色（描点）</span></span><br><span class="line"><span class="comment"> * 输入参数： x坐标，y坐标，颜色</span></span><br><span class="line"><span class="comment"> * 输出参数： 无</span></span><br><span class="line"><span class="comment"> * 返 回 值： 会</span></span><br><span class="line"><span class="comment"> * 修改日期        版本号     修改人	      修改内容</span></span><br><span class="line"><span class="comment"> * -----------------------------------------------</span></span><br><span class="line"><span class="comment"> * 2020/05/12	     V1.0	  zh(angenao)	      创建</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcd_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *pen_8 = fb_base+y*line_width+x*pixel_width;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *pen_16;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *pen_32;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">	pen_16 = (<span class="type">unsigned</span> <span class="type">short</span> *)pen_8;</span><br><span class="line">	pen_32 = (<span class="type">unsigned</span> <span class="type">int</span> *)pen_8;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (var.bits_per_pixel)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			*pen_8 = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 565 */</span></span><br><span class="line">			red   = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			green = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			blue  = (color &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			color = ((red &gt;&gt; <span class="number">3</span>) &lt;&lt; <span class="number">11</span>) | ((green &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">5</span>) | (blue &gt;&gt; <span class="number">3</span>);</span><br><span class="line">			*pen_16 = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			*pen_32 = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t surport %dbpp\n&quot;</span>, var.bits_per_pixel);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	fd_fb = <span class="built_in">open</span>(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_fb &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/fb0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_fb, FBIOGET_VSCREENINFO, &amp;var))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get var\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	line_width  = var.xres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	pixel_width = var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	fb_base = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span> , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fb_base == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清屏: 全部设为白色 */</span></span><br><span class="line">	<span class="built_in">memset</span>(fb_base, <span class="number">0xff</span>, screen_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 随便设置出100个为红色 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">		<span class="built_in">lcd_put_pixel</span>(var.xres/<span class="number">2</span>+i, var.yres/<span class="number">2</span>, <span class="number">0xFF0000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">munmap</span>(fb_base , screen_size);</span><br><span class="line">	<span class="built_in">close</span>(fd_fb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-7输入系统</title>
    <url>/2022/07/26/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-7%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="linux-应用开发-7-输入系统"><a href="#linux-应用开发-7-输入系统" class="headerlink" title="linux 应用开发-7 输入系统"></a><div align = "center">linux 应用开发-7 输入系统</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-7-%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9Fdiv"><div align = "center">linux 应用开发-7 输入系统</div></a><ul>
<li><a href="#%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0">框架概述</a></li>
<li><a href="#app-%E5%BE%97%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE">APP 得到的数据</a></li>
<li><a href="#%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF">调试信息</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E4%BF%A1%E6%81%AF%E5%91%BD%E4%BB%A4">读取信息命令</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F">读取数据的方式</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><blockquote>
<p>先来了解什么是输入设备？</p>
<blockquote>
<p>常见的输入设备有键盘、鼠标、遥控杆、书写板、触摸屏等等,用户通过这些输入设备与 Linux 系统进行数据交换。</p>
</blockquote>
</blockquote>
<blockquote>
<p>什么是输入系统？<br>输入设备种类繁多，能否统一它们的接口？既在驱动层面统一，也在应用程序层面统一？可以的。</p>
<blockquote>
<p>Linux 系统为了统一管理这些输入设备，实现了一套能兼容所有输入设备的框架：输入系统。驱动开发人员基于这套框架开发出程序，应用开发人员就可以使用统一的 API 去使用设备。</p>
</blockquote>
</blockquote>
<div align=center><img  src ="https://pic.imgdb.cn/item/62df9f3cf54cd3f9375fcfa0.jpg"/></div>

<p>访问设备节点流程:<br><span id="inline-toc">1.</span>APP 发起读操作，若无数据则休眠<br><span id="inline-toc">2.</span>用户操作设备，硬件上产生中断<br><span id="inline-toc">3.</span></p>
<blockquote>
<p>输入系统驱动层对应的驱动程序处理中断</p>
<blockquote>
<p>读取到数据，转换为标准的输入事件，向核心层汇报。<br>所谓输入事件就是一个“struct input_event”结构体</p>
</blockquote>
</blockquote>
<p><span id="inline-toc">4.</span></p>
<blockquote>
<p>输入系统驱动层对应的驱动程序处理中断</p>
<blockquote>
<p>从 handler 的名字来看，它就是用来处输入操作的。有多种 handler，比如：evdev_handler、kbd_handler、joydev_handler 等等。<br>最常用的是 evdev_handler：它只是把 input_event 结构体保存在内核 buffer 等，APP 来读取时就原原本本地返回。它支持多个 APP 同时访问输入设备，每个 APP 都可以获得同一份输入事件。<br>当 APP 正在等待数据时，evdev_handler 会把它唤醒，这样 APP 就可以返回数据</p>
</blockquote>
</blockquote>
<p><span id="inline-toc">5.</span></p>
<blockquote>
<p>APP 对输入事件的处理</p>
<blockquote>
<p>APP 获得数据的方法有 2 种：直接访问设备节点(比如&#x2F;dev&#x2F;input&#x2F;event0,1,2,…)，或者通过 tslib、libinput 这类库来间接访问设备节点。这些库简化了对数据的处理。</p>
</blockquote>
</blockquote>
<h2 id="APP-得到的数据"><a href="#APP-得到的数据" class="headerlink" title="APP 得到的数据"></a>APP 得到的数据</h2><p><span id="inline-toc">1.</span></p>
<div class="note info"><p>内核中通过input_dev结构体来表示输入设备</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dfa3e4f54cd3f937796f6d.jpg"/></div>

<p><span id="inline-toc">2.</span></p>
<div class="note info"><p>APP得到数据input_event中,和timeval表示时间</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dfa480f54cd3f9377ccaea.jpg"/></div>

<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>:表示哪类事件</span><br><span class="line"></span><br><span class="line"><span class="title">code</span>:表示该类事件下的哪一个事件</span><br><span class="line"></span><br><span class="line"><span class="title">value</span>:表示事件值</span><br><span class="line"></span><br><span class="line">事件之间的界线,上报完事件后需要添加一个同步事件,它的<span class="keyword">type</span>、code、value三项都是0</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dfa560f54cd3f9378172d9.jpg"/></div>

<h2 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h2><p>输入设备的设备节点名为&#x2F;dev&#x2F;input&#x2F;eventX(也可能是&#x2F;dev&#x2F;eventX，X 表示 0、1、2 等数字)。查看设备节点，可以执行以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ls <span class="regexp">/dev/i</span>nput/* -l</span><br><span class="line">或</span><br><span class="line">ls <span class="regexp">/dev/</span>event* -l</span><br></pre></td></tr></table></figure>

<p>怎么知道这些设备节点对应什么硬件呢？可以在板子上执行以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>bus<span class="regexp">/input/</span>devices</span><br></pre></td></tr></table></figure>

<p>这条指令的含义就是获取与 event 对应的相关设备信息，可以看到类似以下的结果：</p>
<div align=center><img  src ="https://pic.imgdb.cn/item/62dfa669f54cd3f937871c1e.jpg"/></div>

<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">I</span>:<span class="variable">id</span> <span class="variable">of</span> <span class="variable">the</span> <span class="function"><span class="title">device</span>(设备<span class="variable">ID</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">N</span>:<span class="variable">name</span> <span class="variable">of</span> <span class="variable">the</span> <span class="function"><span class="title">device</span>(设备名称)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">P</span>:<span class="variable">physical</span> <span class="variable">path</span> <span class="variable">to</span> <span class="variable">the</span> <span class="variable">device</span> <span class="variable"><span class="keyword">in</span></span> <span class="variable">the</span> <span class="variable">system</span> <span class="function"><span class="title">hierarchy</span>(系统层次结构中设备的物理路径)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">S</span>:<span class="variable">sysfs</span> <span class="function"><span class="title">path</span>(位于<span class="variable">sys</span>文件系统的路径)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">U</span>:<span class="variable">unique</span> <span class="variable">identification</span> <span class="variable">code</span> <span class="variable">for</span> <span class="variable">the</span> <span class="function"><span class="title">device</span>(<span class="variable"><span class="keyword">if</span></span> <span class="variable">device</span> <span class="variable">has</span> <span class="variable">it</span>)(设备的唯一标识码)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">H</span>:<span class="variable">list</span> <span class="variable">of</span> <span class="variable">input</span> <span class="variable">handles</span> <span class="variable">associated</span> <span class="variable">with</span> <span class="variable">the</span> <span class="variable">device</span>.(与设备关联的输入句柄列表)</span><br><span class="line"></span><br><span class="line"><span class="variable">B</span>:<span class="function"><span class="title">bitmaps</span>(位图)</span></span><br><span class="line">    <span class="variable">PROP</span>:<span class="variable">device</span> <span class="variable">properties</span> <span class="variable"><span class="keyword">and</span></span> <span class="function"><span class="title">quirks</span>(设备属性)</span></span><br><span class="line">    <span class="variable">EV</span>:<span class="variable">types</span> <span class="variable">of</span> <span class="variable">events</span> <span class="variable">supported</span> <span class="variable">by</span> <span class="variable">the</span> <span class="function"><span class="title">device</span>(设备支持的事件类型)</span></span><br><span class="line">    <span class="variable">KEY</span>:<span class="variable">keys</span>/<span class="variable">buttons</span> <span class="variable">this</span> <span class="variable">device</span> <span class="function"><span class="title">has</span>(此设备具有的键/按钮)</span></span><br><span class="line">    <span class="variable">MSC</span>:<span class="variable">miscellaneous</span> <span class="variable">events</span> <span class="variable">supported</span> <span class="variable">by</span> <span class="variable">the</span> <span class="function"><span class="title">device</span>(设备支持的其他事件)</span></span><br><span class="line">    <span class="variable">LED</span>:<span class="variable">leds</span> <span class="variable">present</span> <span class="variable">on</span> <span class="variable">the</span> <span class="function"><span class="title">device</span>(设备上的指示灯)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dfa742f54cd3f9378b9b45.jpg"/></div>

<h2 id="读取信息命令"><a href="#读取信息命令" class="headerlink" title="读取信息命令"></a>读取信息命令</h2><p>调试输入系统时，直接执行类似下面的命令，然后操作对应的输入设备即可读出数据：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexdump <span class="regexp">/dev/i</span>nput/event0</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dfa79ff54cd3f9378d7d1f.jpg"/></div>

<h2 id="读取数据的方式"><a href="#读取数据的方式" class="headerlink" title="读取数据的方式"></a>读取数据的方式</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">查询:</span><br><span class="line">    <span class="keyword">APP</span>调用<span class="keyword">open</span>函数时，传入“O_NONBLOCK”表示“非阻塞”。</span><br><span class="line">    <span class="keyword">APP</span>调用<span class="keyword">read</span>函数读取数据时，如果驱动程序中有数据，那么<span class="keyword">APP</span>的<span class="keyword">read</span>函数会返回数据，否则也会立刻返回错误。</span><br><span class="line"></span><br><span class="line">休眠-唤醒方式:</span><br><span class="line">    PP调用<span class="keyword">open</span>函数时，不要传入“O_NONBLOCK”。</span><br><span class="line">    <span class="keyword">APP</span>调用<span class="keyword">read</span>函数读取数据时，如果驱动程序中有数据，那么<span class="keyword">APP</span>的<span class="keyword">read</span>函数会返回数据；否则<span class="keyword">APP</span>就会在内核态休眠，当有数据时驱动程序会把<span class="keyword">APP</span>唤醒，<span class="keyword">read</span>函数恢复执行并返回数据给<span class="keyword">APP</span></span><br><span class="line"></span><br><span class="line">POLL/SELECT方式:</span><br><span class="line">    定时查询</span><br><span class="line"></span><br><span class="line">异步通知方式:</span><br><span class="line">    所谓异步通知，就是<span class="keyword">APP</span>可以忙自己的事，当驱动程序用数据时它会主动给<span class="keyword">APP</span>发信号，这会导致<span class="keyword">APP</span>执行信号处理函数。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-4文件IO</title>
    <url>/2022/07/24/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-4%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<h1 id="linux-应用开发-4-文件-IO"><a href="#linux-应用开发-4-文件-IO" class="headerlink" title="linux 应用开发-4 文件 IO"></a><div align = "center">linux 应用开发-4 文件 IO</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-4-%E6%96%87%E4%BB%B6-iodiv"><div align = "center">linux 应用开发-4 文件 IO</div></a><ul>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5">文件从哪里来</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6">访问文件</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%8E%9F%E7%90%86">访问原理</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="文件从哪里来"><a href="#文件从哪里来" class="headerlink" title="文件从哪里来"></a>文件从哪里来</h2><blockquote>
<p>磁盘,flash,SD 卡,U 盘</p>
<blockquote>
<p>真实文件,以某种格式保存在某个设备上,要先 <span id="inline-red"> mount </span></p>
</blockquote>
</blockquote>
<blockquote>
<p>linux 内核提供的虚拟文件系统</p>
<blockquote>
<p>也要先<span id="inline-red"> mount </span></p>
</blockquote>
</blockquote>
<blockquote>
<p>特殊文件:&#x2F;dev&#x2F;xxx,设备节点:字符设备,块设备</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">查看挂载的设备:</span><br><span class="line">    cat <span class="regexp">/proc/m</span>ounts</span><br><span class="line"></span><br><span class="line">挂载命令:</span><br><span class="line">    mount <span class="regexp">/dev/</span>sda1 /mnt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h2><div class="note success"><p>设备分为字符设备,块设备和网络设备</p></div>
<div class="note success"><p>同时设备号也分成主设备号,次设备号  
主设备号负责哪个驱动,次设备号负责哪个硬件</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dd0daaf54cd3f937578674.jpg"/></div>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">通用访问文件接口:</span><br><span class="line">    open<span class="regexp">/read/</span>writhe<span class="regexp">/lseek/</span>close</span><br><span class="line"></span><br><span class="line">不通用接口:</span><br><span class="line">    ioctl/mmap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dd0f19f54cd3f93760b25b.jpg"/></div>

<h2 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h2><div align=center><img  src ="https://pic.imgdb.cn/item/62dd11c9f54cd3f937706ef6.jpg"/></div>

<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">当<span class="keyword">APP</span>,用户态调用<span class="keyword">open</span>等接口时,会触发CPU异常</span><br><span class="line">CPU会调用swi,svi等函数,传输对应数组到内核</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62dd12abf54cd3f93775be16.jpg"/></div>

<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">当内核接受到APP的调用sys_open等函数时,会先判断文件的类型</span><br><span class="line"></span><br><span class="line">FAT32<span class="regexp">/EXT4/</span>...等普通文件-&gt;块设备驱动</span><br><span class="line"></span><br><span class="line">设备节点-&gt;以主设备号来寻找字符设备驱动</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-9多线程编程</title>
    <url>/2022/08/02/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="linux-应用开发-9-多线程编程"><a href="#linux-应用开发-9-多线程编程" class="headerlink" title="linux 应用开发-9 多线程编程"></a><div align = "center">linux 应用开发-9 多线程编程</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bdiv"><div align = "center">linux 应用开发-9 多线程编程</div></a><ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">线程的创建</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA">线程退出</a></li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">条件变量</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">怎么创建线程呢？使用pthread_create函数：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数第一个参数为 pthread_t 指针，用来保存新建线程的线程号；<br>第二个参数表示了线程的属性，一般传入 NULL 表示默认属性；<br>第三个参数是一个函数指针，就是线程执行的函数。这个函数返回值为 void<em>，形参为 void</em>。<br>第四个参数则表示为向线程处理函数传入的参数，若不传入，可用 NULL 填充，有关线程传参后续小节会有详细的说明，接下来通过一个简单例程来使用该函数创建出一个线程。</p>
</blockquote>
<h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 线程主动退出</span><br><span class="line">pthread_exit函数原型如下：</span><br><span class="line">线程主动退出</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>;</span><br><span class="line">pthread_exit函数为线程退出函数，在退出时候可以传递一个<span class="type">void</span>*类型的数据带给主线程，若选择不传出数据，可将参数填充为<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 线程被动退出</span><br><span class="line">pthread_cancel函数原型如下：</span><br><span class="line">线程被动退出，其他线程使用该函数让另一个线程退出</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line">成功：返回<span class="number">0</span></span><br><span class="line">该函数传入一个tid号，会强制退出该tid所指向的线程，若成功执行会返回<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><div class="note success"><p>避免多线程资源的竞争问题,人们采用了互斥锁等方法</p></div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化互斥量</span><br><span class="line">函数原型如下：</span><br><span class="line">初始化互斥量</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">phtread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *restrict attr)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数初始化一个互斥量，第一个参数是改互斥量指针<br>第二个参数为控制互斥量的属性，一般为 NULL。当函数成功后会返回 0，代表初始化互斥量成功。</p>
</blockquote>
<p>当然初始化互斥量也可以调用宏来快速初始化，代码如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">pthread_mutex_t mutex <span class="operator">=</span> PTHREAD_MUTEX_INITALIZER<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">互斥量加锁/解锁</span><br><span class="line">函数原型如下：</span><br><span class="line">互斥量加锁（阻塞）/解锁</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">成功：返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>lock 函数与 unlock 函数分别为加锁解锁函数，只需要传入已经初始化好的 pthread_mutex_t 互斥量指针。成功后会返回 0。<br>当某一个线程获得了执行权后，执行 lock 函数，一旦加锁成功后，其余线程遇到 lock 函数时候会发生阻塞，直至获取资源的线程执行 unlock 函数后。unlock 函数会唤醒其他正在等待互斥量的线程。<br>特别注意的是，当获取 lock 之后，必须在逻辑处理结束后执行 unlock，否则会发生死锁现象！导致其余线程一直处于阻塞状态，无法执行下去。在使用互斥量的时候，尤其要注意使用 pthread_cancel 函数，防止发生死锁现象！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">互斥量加锁(非阻塞方式)</span><br><span class="line">函数原型如下：</span><br><span class="line">互斥量加锁（非阻塞）</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数同样也是一个线程加锁函数，但该函数是非阻塞模式通过返回值来判断是否加锁成功，用法与上述阻塞加锁函数一致。</p>
</blockquote>
<p>互斥量销毁(非祖师方式)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数原型如下：</span><br><span class="line">互斥量销毁</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">成功：返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数是用于销毁互斥量的，传入互斥量的指针，就可以完成互斥量的销毁，成功返回 0。</p>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>注意：信号量跟互斥量不一样，互斥量用来防止多个线程同时访问某个临界资源。信号量起通知作用，线程 A 在等待某件事，线程 B 完成了这件事后就可以给线程 A 发信号。</p>
<p><span id="inline-toc">1.</span> 初始化信号量<br>函数原型如下：<br>初始化信号量</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;semaphore.h&gt;</span><br><span class="line"><span class="built_in">int</span> sem<span class="constructor">_init(<span class="params">sem_t</span> <span class="operator">*</span><span class="params">sem</span>,<span class="params">int</span> <span class="params">pshared</span>,<span class="params">unsigned</span> <span class="params">int</span> <span class="params">value</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数可以初始化一个信号量，第一个参数传入 sem_t 类型指针；<br>第二个参数传入 0 代表线程控制，否则为进程控制；<br>第三个参数表示信号量的初始值，0 代表阻塞，1 代表运行。<br>待初始化结束信号量后，若执行成功会返回 0。</p>
</blockquote>
<p><span id="inline-toc">2.</span> 信号量 P&#x2F;V 操作<br>函数原型如下：<br>信号量 PV 操作（阻塞）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">成功：返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sem_wait 函数作用为检测指定信号量是否有资源可用，若无资源可用会阻塞等待，若有资源可用会自动的执行“sem-1”的操作。所谓的“sem-1”是与上述初始化函数中第三个参数值一致，成功执行会返回 0。<br>sem_post 函数会释放指定信号量的资源，执行“sem+1”操作。<br>通过以上 2 个函数可以完成所谓的 PV 操作，即信号量的申请与释放，完成对线程执行顺序的控制。</p>
</blockquote>
<p><span id="inline-toc">3.</span> 信号量申请(非阻塞方式)<br>函数原型如下：<br>信号量申请资源（非阻塞）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">成功：返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>此函数是信号量申请资源的非阻塞函数，功能与 sem_wait 一致，唯一区别在于此函数为非阻塞。</p>
<p><span id="inline-toc">4.</span> 信号量销毁<br>函数原型如下：<br>信号量销毁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destory</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">成功：返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>该函数为信号量销毁函数，执行过后可将信号量进行销毁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> g_buf[<span class="number">1000</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> g_sem;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">my_thread_func</span> <span class="params">(<span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//sleep(1);</span></span><br><span class="line">		<span class="comment">/* 等待通知 */</span></span><br><span class="line">		<span class="comment">//while (g_hasData == 0);</span></span><br><span class="line">		<span class="built_in">sem_wait</span>(&amp;g_sem);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 打印 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, g_buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sem_init</span>(&amp;g_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1. 创建&quot;接收线程&quot; */</span></span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, my_thread_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create err!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 主线程读取标准输入, 发给&quot;接收线程&quot; */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fgets</span>(g_buf, <span class="number">1000</span>, stdin);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 通知接收线程 */</span></span><br><span class="line">		<span class="built_in">sem_post</span>(&amp;g_sem);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量时一种同步机制，用来通知其他线程条件满足了。一般是用来通知对方共享数据的状态信息，因此条件变量时结合互斥量来使用的。</p>
<p><span id="inline-toc">1.</span> 创建和销毁条件变量<br>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span></span>;<span class="comment">//cond_attr通常为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁条件变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line">这些函数成功时都返回<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><span id="inline-toc">2.</span> 等待条件变量<br>函数原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_cond_wait(<span class="params">pthread_cond_t</span> <span class="operator">*</span><span class="params">cond</span>, <span class="params">pthread_mutex_t</span> <span class="operator">*</span><span class="params">mutex</span>)</span>;</span><br><span class="line"></span><br><span class="line">这需要结合互斥量一起使用，示例代码如下：</span><br><span class="line">pthread<span class="constructor">_mutex_lock(&amp;<span class="params">g_tMutex</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_cond_wait(&amp;<span class="params">g_tConVar</span>, &amp;<span class="params">g_tMutex</span>)</span>;  <span class="comment">// 如果条件不满足则，会unlock g_tMutex</span></span><br><span class="line">                                           <span class="comment">// 条件满足后被唤醒，会lock g_tMutex</span></span><br><span class="line"> <span class="comment">/* 操作临界资源 */</span></span><br><span class="line">pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">g_tMutex</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><span id="inline-toc">3.</span> 通知条件变量<br>函数原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_cond_signal(<span class="params">pthread_cond_t</span> <span class="operator">*</span><span class="params">cond</span>)</span>;</span><br><span class="line"></span><br><span class="line">pthread_cond_signal函数只会唤醒一个等待cond条件变量的线程，示例代码如下：</span><br><span class="line">pthread<span class="constructor">_cond_signal(&amp;<span class="params">g_tConVar</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> g_buf[<span class="number">1000</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> g_tMutex  = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span>  g_tConVar = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">my_thread_func</span> <span class="params">(<span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//sleep(1);</span></span><br><span class="line">		<span class="comment">/* 等待通知 */</span></span><br><span class="line">		<span class="comment">//while (g_hasData == 0);</span></span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;g_tMutex);</span><br><span class="line">		<span class="built_in">pthread_cond_wait</span>(&amp;g_tConVar, &amp;g_tMutex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 打印 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, g_buf);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;g_tMutex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1. 创建&quot;接收线程&quot; */</span></span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, my_thread_func, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create err!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 主线程读取标准输入, 发给&quot;接收线程&quot; */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fgets</span>(buf, <span class="number">1000</span>, stdin);</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;g_tMutex);</span><br><span class="line">		<span class="built_in">memcpy</span>(g_buf, buf, <span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;g_tConVar); <span class="comment">/* 通知接收线程 */</span></span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;g_tMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-6文字显示及图像显示</title>
    <url>/2022/07/25/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-6%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="linux-应用开发-6-文字显示及图像显示"><a href="#linux-应用开发-6-文字显示及图像显示" class="headerlink" title="linux 应用开发-6 文字显示及图像显示"></a><div align = "center">linux 应用开发-6 文字显示及图像显示</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-6-%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BAdiv"><div align = "center">linux 应用开发-6 文字显示及图像显示</div></a><ul>
<li><a href="#%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA">文字显示</a></li>
<li><a href="#ascii-%E5%AD%97%E7%AC%A6%E7%82%B9%E9%98%B5%E6%98%BE%E7%A4%BA">ASCII 字符点阵显示</a></li>
<li><a href="#%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%82%B9%E9%98%B5%E6%98%BE%E7%A4%BA">中文字符点阵显示</a></li>
<li><a href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F">交叉编译程序</a></li>
<li><a href="#freetype-%E6%98%BE%E7%A4%BA%E6%96%87%E5%AD%97">freetype 显示文字</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="文字显示"><a href="#文字显示" class="headerlink" title="文字显示"></a>文字显示</h2><p><span id="inline-toc">1.</span>ASCII 码</p>
<div class="note primary"><p>ASCII码比较局限,仅包含了英文,符号及数字而已,没有汉字</p></div>

<p><span id="inline-toc">2.</span>ANSI 码</p>
<div class="note primary"><p>ANSI码,包含汉字,但还是有局限性,不同字符集下,显示的文字不同</p></div>

<p><span id="inline-toc">3.</span>unicode(统一编码)</p>
<div class="note primary"><p>unicode编码,任意字符都给了唯一的数值表示;数值范围是:0x0000 ~ 0x10FFFF,有100多万个数值,足够地球人使用了</p></div>

<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">unicode分为三种编码方式:</span><br><span class="line">  utf<span class="string">-16</span> LE, utf<span class="string">-16</span> BE, utf<span class="string">-8</span></span><br><span class="line"></span><br><span class="line">utf<span class="string">-16</span> LE</span><br><span class="line">  就是小端编码,权重大的放后面</span><br><span class="line"></span><br><span class="line">utf<span class="string">-16</span> BE</span><br><span class="line">  就是大端编码,权重大的放前面</span><br><span class="line"></span><br><span class="line">utf<span class="string">-8</span></span><br><span class="line">  就是通过组合三个或两个字节来表示一个字符,第一个字节表示位数,第二个表示字符</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62de579cf54cd3f937f3fa6d.jpg"/></div>

<h2 id="ASCII-字符点阵显示"><a href="#ASCII-字符点阵显示" class="headerlink" title="ASCII 字符点阵显示"></a>ASCII 字符点阵显示</h2><p>知道字符,如何通过字符寻找点阵信息呢?<br>linux 内核中已经写好了</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> c = <span class="string">&#x27;A&#x27;</span>;<span class="meta">#C就是A的ASCII编码了</span></span><br><span class="line"></span><br><span class="line">找到front.h文件,有很多,<span class="number">8</span>x16就是横向用<span class="number">8</span>个像素表示,纵向用<span class="number">16</span>像素表示</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62de5975f54cd3f937fd974d.jpg"/></div>

<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">点阵数组中一行用一个字节来表示<span class="comment">(8位 0xFF)</span></span><br><span class="line">每一位就是一个像素,总共<span class="number">0</span>~<span class="number">15</span>行</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62de59fcf54cd3f937004306.jpg"/></div>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcd_put_ascii</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;fontdata_8x16[c*<span class="number">16</span>];</span><br><span class="line">	<span class="type">int</span> i, b;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> <span class="type">byte</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">byte</span> = dots[i];</span><br><span class="line">		<span class="keyword">for</span> (b = <span class="number">7</span>; b &gt;= <span class="number">0</span>; b--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="type">byte</span> &amp; (<span class="number">1</span>&lt;&lt;b))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* show */</span></span><br><span class="line">				<span class="built_in">lcd_put_pixel</span>(x+<span class="number">7</span>-b, y+i, <span class="number">0xffffff</span>); <span class="comment">/* 白 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* hide */</span></span><br><span class="line">				<span class="built_in">lcd_put_pixel</span>(x+<span class="number">7</span>-b, y+i, <span class="number">0</span>); <span class="comment">/* 黑 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fd_fb = <span class="built_in">open</span>(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_fb &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/fb0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_fb, FBIOGET_VSCREENINFO, &amp;var))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get var\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	line_width  = var.xres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	pixel_width = var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	fbmem = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span> , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fbmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清屏: 全部设为黑色 */</span></span><br><span class="line">	<span class="built_in">memset</span>(fbmem, <span class="number">0</span>, screen_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">lcd_put_ascii</span>(var.xres/<span class="number">2</span>, var.yres/<span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">/*在屏幕中间显示8*16的字母A*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">munmap</span>(fbmem , screen_size);</span><br><span class="line">	<span class="built_in">close</span>(fd_fb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中文字符点阵显示"><a href="#中文字符点阵显示" class="headerlink" title="中文字符点阵显示"></a>中文字符点阵显示</h2><div class="note primary"><p>中文字符由于字符编码不同,可能会影响显示</p></div>

<p>我们可以指定编码格式</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">-finput-charset</span>=GB2312  <span class="attribute">-fexec-charset</span>=UTF-8    #把文件中的GB2312改成UTF-8</span><br><span class="line"></span><br><span class="line"><span class="attribute">-finput-charset</span>=UTF-8   <span class="attribute">-fexec-charset</span>=GB2312   #把文件中的UTF-8改成GB2312</span><br><span class="line"></span><br><span class="line">真正使用时:</span><br><span class="line">  gcc <span class="attribute">-finput-charset</span>=GB2312 <span class="attribute">-fexec-charset</span>=UTF-8 -o test test.c</span><br></pre></td></tr></table></figure>

<div class="note primary"><p>中文点阵库(HZK16),是以GB2312来索引的</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62de5f18f54cd3f937193894.jpg"/></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62de5fa4f54cd3f9371bce1b.jpg"/></div>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcd_put_chinese</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> area  = str[<span class="number">0</span>] - <span class="number">0xA1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> where = str[<span class="number">1</span>] - <span class="number">0xA1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = hzkmem + (area * <span class="number">94</span> + where)*<span class="number">32</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> <span class="type">byte</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, j, b;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">byte</span> = dots[i*<span class="number">2</span> + j];</span><br><span class="line">			<span class="keyword">for</span> (b = <span class="number">7</span>; b &gt;=<span class="number">0</span>; b--)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="type">byte</span> &amp; (<span class="number">1</span>&lt;&lt;b))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* show */</span></span><br><span class="line">					<span class="built_in">lcd_put_pixel</span>(x+j*<span class="number">8</span>+<span class="number">7</span>-b, y+i, <span class="number">0xffffff</span>); <span class="comment">/* 白 */</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* hide */</span></span><br><span class="line">					<span class="built_in">lcd_put_pixel</span>(x+j*<span class="number">8</span>+<span class="number">7</span>-b, y+i, <span class="number">0</span>); <span class="comment">/* 黑 */</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[] = <span class="string">&quot;中&quot;</span>;</span><br><span class="line"></span><br><span class="line">	fd_fb = <span class="built_in">open</span>(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_fb &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/fb0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_fb, FBIOGET_VSCREENINFO, &amp;var))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get var\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	line_width  = var.xres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	pixel_width = var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	fbmem = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span> , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fbmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd_hzk16 = <span class="built_in">open</span>(<span class="string">&quot;HZK16&quot;</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd_hzk16 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open HZK16\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fstat</span>(fd_hzk16, &amp;hzk_stat))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get fstat\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	hzkmem = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span> , hzk_stat.st_size, PROT_READ, MAP_SHARED, fd_hzk16, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hzkmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap for hzk16\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清屏: 全部设为黑色 */</span></span><br><span class="line">	<span class="built_in">memset</span>(fbmem, <span class="number">0</span>, screen_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lcd_put_ascii</span>(var.xres/<span class="number">2</span>, var.yres/<span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">/*在屏幕中间显示8*16的字母A*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chinese code: %02x %02x\n&quot;</span>, str[<span class="number">0</span>], str[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">lcd_put_chinese</span>(var.xres/<span class="number">2</span> + <span class="number">8</span>,  var.yres/<span class="number">2</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">munmap</span>(fbmem , screen_size);</span><br><span class="line">	<span class="built_in">close</span>(fd_fb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译程序"><a href="#交叉编译程序" class="headerlink" title="交叉编译程序"></a>交叉编译程序</h2><div align=center><img  src ="https://pic.imgdb.cn/item/62de6531f54cd3f9373637c3.jpg"/></div>

<h2 id="freetype-显示文字"><a href="#freetype-显示文字" class="headerlink" title="freetype 显示文字"></a>freetype 显示文字</h2><p>freetype 可以实现文字的旋转,放大,缩小等操作</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 驱动开发-1HELLO驱动</title>
    <url>/2022/08/03/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1HELLO%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="linux-驱动开发-1HELLO-驱动"><a href="#linux-驱动开发-1HELLO-驱动" class="headerlink" title="linux 驱动开发-1HELLO 驱动"></a><div align = "center">linux 驱动开发-1HELLO 驱动</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-1hello-%E9%A9%B1%E5%8A%A8div"><div align = "center">linux 驱动开发-1HELLO 驱动</div></a><ul>
<li><a href="#%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6">驱动框架</a></li>
<li><a href="#hello-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">HELLO 驱动程序</a></li>
<li><a href="#hello-%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">HELLO 测试应用程序</a></li>
<li><a href="#makefile">MAKEFILE</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><blockquote>
<p><span id="inline-toc">1.</span>确定主设备号，也可以让内核分配</p>
</blockquote>
<blockquote>
<p><span id="inline-toc">2.</span> 定义自己的 file_operations 结构体</p>
</blockquote>
<blockquote>
<p><span id="inline-toc">3.</span> 实现对应的 drv_open&#x2F;drv_read&#x2F;drv_write 等函数，填入 file_operations 结构体</p>
</blockquote>
<blockquote>
<p><span id="inline-toc">4.</span> 把 file_operations 结构体告诉内核：register_chrdev</p>
</blockquote>
<blockquote>
<p><span id="inline-toc">5.</span> 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数</p>
</blockquote>
<blockquote>
<p><span id="inline-toc">6.</span> 有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用 unregister_chrdev</p>
</blockquote>
<blockquote>
<p><span id="inline-toc">7.</span> 其他完善：提供设备信息，自动创建设备节点：class_create, device_create</p>
</blockquote>
<h2 id="HELLO-驱动程序"><a href="#HELLO-驱动程序" class="headerlink" title="HELLO 驱动程序"></a>HELLO 驱动程序</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号                                                                 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">class</span> *hello_class;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	err = <span class="built_in">copy_to_user</span>(buf, kernel_buf, <span class="built_in">MIN</span>(<span class="number">1024</span>, size));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">MIN</span>(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	err = <span class="built_in">copy_from_user</span>(kernel_buf, buf, <span class="built_in">MIN</span>(<span class="number">1024</span>, size));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">MIN</span>(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operations结构体                                              */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> hello_drv = &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = hello_drv_open,</span><br><span class="line">	.read    = hello_drv_read,</span><br><span class="line">	.write   = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 把file_operations结构体告诉内核：注册驱动程序                                */</span></span><br><span class="line"><span class="comment">/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	major = <span class="built_in">register_chrdev</span>(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);  <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	hello_class = <span class="built_in">class_create</span>(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">	err = <span class="built_in">PTR_ERR</span>(hello_class);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(hello_class)) &#123;</span><br><span class="line">		<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="built_in">unregister_chrdev</span>(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">device_create</span>(hello_class, <span class="literal">NULL</span>, <span class="built_in">MKDEV</span>(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数           */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="built_in">device_destroy</span>(hello_class, <span class="built_in">MKDEV</span>(major, <span class="number">0</span>));</span><br><span class="line">	<span class="built_in">class_destroy</span>(hello_class);</span><br><span class="line">	<span class="built_in">unregister_chrdev</span>(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HELLO-测试应用程序"><a href="#HELLO-测试应用程序" class="headerlink" title="HELLO 测试应用程序"></a>HELLO 测试应用程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test -w abc</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test -r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1. 判断参数 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s -w &lt;string&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;       %s -r\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. 写文件或读文件 */</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-w&quot;</span>)) &amp;&amp; (argc == <span class="number">3</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		len = <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">		len = len &lt; <span class="number">1024</span> ? len : <span class="number">1024</span>;</span><br><span class="line">		<span class="built_in">write</span>(fd, argv[<span class="number">2</span>], len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		len = <span class="built_in">read</span>(fd, buf, <span class="number">1024</span>);</span><br><span class="line">		buf[<span class="number">1023</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;APP read : %s\n&quot;</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MAKEFILE"><a href="#MAKEFILE" class="headerlink" title="MAKEFILE"></a>MAKEFILE</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.1 ARCH,          比如: <span class="built_in">export</span> ARCH=arm64</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.2 CROSS_COMPILE, 比如: <span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.3 PATH,          比如: <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      请参考各开发板的高级用户使用手册</span></span><br><span class="line"></span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	make -C $(KERN_DIR) M=`pwd` modules</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CROSS_COMPILE)gcc -o hello_drv_test hello_drv_test.c</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C $(KERN_DIR) M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f hello_drv_test</span><br><span class="line"></span><br><span class="line">obj-m	+= hello_drv.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 驱动开发-2LED驱动</title>
    <url>/2022/08/07/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-2LED%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="linux-驱动开发-2LED-驱动"><a href="#linux-驱动开发-2LED-驱动" class="headerlink" title="linux 驱动开发-2LED 驱动"></a><div align = "center">linux 驱动开发-2LED 驱动</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-2led-%E9%A9%B1%E5%8A%A8div"><div align = "center">linux 驱动开发-2LED 驱动</div></a><ul>
<li><a href="#led-%E5%9C%B0%E5%9D%80">LED 地址</a></li>
<li><a href="#led-%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99">LED 驱动编写</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="LED-地址"><a href="#LED-地址" class="headerlink" title="LED 地址"></a>LED 地址</h2><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">CCM</span><span class="operator">:</span> <span class="built_in">Clock</span> <span class="variable">Controller</span> <span class="built_in">Module</span> <span class="punctuation">(</span>时钟控制模块<span class="punctuation">)</span></span><br><span class="line"><span class="variable">IOMUXC</span> <span class="operator">:</span> <span class="variable">IOMUX</span> <span class="variable">Controller</span>，<span class="variable">IO</span>复用控制器</span><br><span class="line"><span class="variable">GPIO</span><span class="operator">:</span> <span class="built_in">General</span><span class="operator">-</span><span class="variable">purpose</span> <span class="variable">input</span><span class="operator">/</span><span class="variable">output</span>，通用的输入输出口</span><br></pre></td></tr></table></figure>

<div class="note info"><p>CCM_CCGR1地址：0x020C4000 + 0x6C</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62ef6e2e16f2c2beb134e32e.jpg"/></div>

<div class="note info"><p>IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3地址：0x02290000 + 0x14</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62ef6eb916f2c2beb1372898.jpg"/></div>

<div class="note info"><p>GPIO5_GDIR地址：0x020AC004</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62ef6ef316f2c2beb1381dba.jpg"/></div>

<div class="note info"><p>GPIO5_DR地址：0x020AC000</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62ef6f0516f2c2beb1386c3d.jpg"/></div>

<h2 id="LED-驱动编写"><a href="#LED-驱动编写" class="headerlink" title="LED 驱动编写"></a>LED 驱动编写</h2><blockquote>
<p><span id="inline-toc">1.</span>搭建字符设备驱动框架<br><span id="inline-toc">2.</span>通过 ioremap 映射地址<br><span id="inline-toc">3.</span>对地址进行操作</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO5_GDIR 地址：0x020AC004</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO5_DR 地址：0x020AC000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_DR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = <span class="built_in">ioremap</span>(<span class="number">0x02290000</span> + <span class="number">0x14</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">GPIO5_GDIR = <span class="built_in">ioremap</span>(<span class="number">0x020AC004</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">GPIO5_DR  = <span class="built_in">ioremap</span>(<span class="number">0x020AC000</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set gpio to let led on */</span></span><br><span class="line">		*GPIO5_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set gpio to let led off */</span></span><br><span class="line">        *GPIO5_DR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><span id="inline-red"> led_drv.c </span></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">class</span> *led_class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* registers */</span></span><br><span class="line"><span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO5_GDIR 地址：0x020AC004</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO5_DR 地址：0x020AC000</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_DR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy_from_user : get data from app */</span></span><br><span class="line">	ret = <span class="built_in">copy_from_user</span>(&amp;val, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* to set gpio register: out 1/0 */</span></span><br><span class="line">	<span class="keyword">if</span> (val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* set gpio to let led on */</span></span><br><span class="line">		*GPIO5_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* set gpio to let led off */</span></span><br><span class="line">		*GPIO5_DR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* enable gpio5</span></span><br><span class="line"><span class="comment">	 * configure gpio5_io3 as gpio</span></span><br><span class="line"><span class="comment">	 * configure gpio5_io3 as output</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">	*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 |= <span class="number">0x5</span>;</span><br><span class="line"></span><br><span class="line">	*GPIO5_GDIR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> led_fops = &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.write		= led_write,</span><br><span class="line">	.open		= led_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口函数 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">led_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">	major = <span class="built_in">register_chrdev</span>(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_fops);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ioremap */</span></span><br><span class="line">	<span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span></span><br><span class="line">	IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = <span class="built_in">ioremap</span>(<span class="number">0x02290000</span> + <span class="number">0x14</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GPIO5_GDIR 地址：0x020AC004</span></span><br><span class="line">	GPIO5_GDIR = <span class="built_in">ioremap</span>(<span class="number">0x020AC004</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GPIO5_DR 地址：0x020AC000</span></span><br><span class="line">	GPIO5_DR  = <span class="built_in">ioremap</span>(<span class="number">0x020AC000</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	led_class = <span class="built_in">class_create</span>(THIS_MODULE, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">	<span class="built_in">device_create</span>(led_class, <span class="literal">NULL</span>, <span class="built_in">MKDEV</span>(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;myled&quot;</span>); <span class="comment">/* /dev/myled */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">led_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">iounmap</span>(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3);</span><br><span class="line">	<span class="built_in">iounmap</span>(GPIO5_GDIR);</span><br><span class="line">	<span class="built_in">iounmap</span>(GPIO5_DR);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">device_destroy</span>(led_class, <span class="built_in">MKDEV</span>(major, <span class="number">0</span>));</span><br><span class="line">	<span class="built_in">class_destroy</span>(led_class);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">unregister_chrdev</span>(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(led_init);</span><br><span class="line"><span class="built_in">module_exit</span>(led_exit);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-red"> ledtest.c </span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ledtest /dev/myled on</span></span><br><span class="line"><span class="comment">// ledtest /dev/myled off</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on|off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;  eg: %s /dev/myled on\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;  eg: %s /dev/myled off\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// open</span></span><br><span class="line">	fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		status = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 应用开发-8网络编程</title>
    <url>/2022/08/01/linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="linux-应用开发-8-网络编程"><a href="#linux-应用开发-8-网络编程" class="headerlink" title="linux 应用开发-8 网络编程"></a><div align = "center">linux 应用开发-8 网络编程</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-8-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Bdiv"><div align = "center">linux 应用开发-8 网络编程</div></a><ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0">网络通信概述</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0">网络编程函数</a><ul>
<li><a href="#socket-%E5%87%BD%E6%95%B0">socket 函数</a></li>
<li><a href="#bind-%E5%87%BD%E6%95%B0">bind 函数</a></li>
<li><a href="#listen-%E5%87%BD%E6%95%B0">listen 函数</a></li>
<li><a href="#accept-%E5%87%BD%E6%95%B0">accept 函数</a></li>
<li><a href="#connect-%E5%87%BD%E6%95%B0">connect 函数</a></li>
<li><a href="#send-%E5%87%BD%E6%95%B0">send 函数</a></li>
<li><a href="#recv-%E5%87%BD%E6%95%B0">recv 函数</a></li>
<li><a href="#recvfrom-%E5%87%BD%E6%95%B0--sendto-%E5%87%BD%E6%95%B0">recvfrom 函数 &amp;&amp; sendto 函数</a></li>
</ul>
</li>
<li><a href="#tcp-%E7%A8%8B%E5%BA%8F">TCP 程序</a></li>
<li><a href="#udp-%E7%A8%8B%E5%BA%8F">UDP 程序</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="网络通信概述"><a href="#网络通信概述" class="headerlink" title="网络通信概述"></a>网络通信概述</h2><blockquote class="blockquote-center">
<p>网络通信协议分为两类:TCP,UDP<br>TCP:可靠传输,面向连接<br>UDP:快速传输,面向无连接</p>

</blockquote>

<div align=center><img  src ="https://pic.imgdb.cn/item/62e910b316f2c2beb1204e4b.jpg"/></div>

<h2 id="网络编程函数"><a href="#网络编程函数" class="headerlink" title="网络编程函数"></a>网络编程函数</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">socket</span>函数</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">socket</span>(<span class="keyword">int</span> domain, <span class="keyword">int</span> type,<span class="keyword">int</span> protocol);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此函数用于创建一个套接字。</p>
<blockquote>
<p>domain 是网络程序所在的主机采用的通讯协族(AF_UNIX 和 AF_INET 等)。</p>
<blockquote>
<p>AF_UNIX 只能够用于单一的 Unix 系统进程间通信，而 AF_INET 是针对 Internet 的，因而可以允许远程通信使用。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>type 是网络程序所采用的通讯协议(SOCK_STREAM,SOCK_DGRAM 等)。</p>
<blockquote>
<p>SOCK_STREAM 表明用的是 TCP 协议，这样会提供按顺序的，可靠，双向，面向连接的比特流。<br>SOCK_DGRAM 表明用的是 UDP 协议，这样只会提不可靠，无连接的通信。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>关于 protocol，由于指定了 type，所以这个地方一般只要用 0 来代替就可以了。<br>此函数执行成功时返回文件描述符，失败时返回-1,看 errno 可知道出错的详细情况。</p>
</blockquote>
</blockquote>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bind</span>函数</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">bind</span>(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *my_addr, <span class="keyword">int</span> addrlen);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从函数用于将地址绑定到一个套接字。</p>
<blockquote>
<p>sockfd 是由 socket 函数调用返回的文件描述符。<br>my_addr 是一个指向 sockaddr 的指针。<br>addrlen 是 sockaddr 结构的长度。</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sockaddr的定义：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;</span><br><span class="line">unisgned <span class="type">short</span>  as_family;</span><br><span class="line"><span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">不过由于系统的兼容性,我们一般使用另外一个结构(<span class="keyword">struct</span> sockaddr_in) 来代替。</span><br><span class="line"></span><br><span class="line">sockaddr_in的定义：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>   sin_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>     sin_port;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>   sin_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>   sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 Internet 所以 sin_family 一般为 AF_INET。</p>
<blockquote>
<p>sin_addr 设置为 INADDR_ANY 表示可以和任何的主机通信。<br>sin_port 是要监听的端口号。<br>bind 将本地的端口同 socket 返回的文件描述符捆绑在一起.成功是返回 0,失败的情况和 socket 一样。</p>
</blockquote>
</blockquote>
<h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">listen函数</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此函数宣告服务器可以接受连接请求。</p>
<blockquote>
<p>sockfd 是 bind 后的文件描述符。<br>backlog 设置请求排队的最大长度。当有多个客户端程序和服务端相连时，使用这个表示可以介绍的排队长度。<br>listen 函数将 bind 的文件描述符变为监听套接字，返回的情况和 bind 一样。</p>
</blockquote>
</blockquote>
<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> accept函数</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr,<span class="type">int</span> *addrlen)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务器使用此函数获得连接请求，并且建立连接。</p>
<blockquote>
<p>sockfd 是 listen 后的文件描述符。<br>addr，addrlen 是用来给客户端的程序填写的,服务器端只要传递指针就可以了， bind,listen 和 accept 是服务器端用的函数。<br>accept 调用时，服务器端的程序会一直阻塞到有一个客户程序发出了连接。 accept 成功时返回最后的服务器端的文件描述符，这个时候服务器端可以向该描述符写信息了，失败时返回-1</p>
</blockquote>
</blockquote>
<h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">connect函数</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr * serv_addr,<span class="type">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用 connect 建立一个连接，在 connect 中所指定的地址是想与之通信的服务器的地址。</p>
<blockquote>
<p>sockfd 是 socket 函数返回的文件描述符。<br>serv_addr 储存了服务器端的连接信息，其中 sin_add 是服务端的地址。<br>addrlen 是 serv_addr 的长度<br>connect 函数是客户端用来同服务端连接的.成功时返回 0，sockfd 是同服务端通讯的文件描述符，失败时返回-1。</p>
</blockquote>
</blockquote>
<h3 id="send-函数"><a href="#send-函数" class="headerlink" title="send 函数"></a>send 函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">send函数</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户或者服务器应用程序都用 send 函数来向 TCP 连接的另一端发送数据</p>
<blockquote>
<p>sockfd 指定发送端套接字描述符；<br>buf 指明一个存放应用程序要发送数据的缓冲区；<br>len 指明实际要发送的数据的字节数；<br>flags 一般置 0。</p>
</blockquote>
</blockquote>
<h3 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv 函数"></a>recv 函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">recv函数</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户或者服务器应用程序都用 recv 函数从 TCP 连接的另一端接收数据</p>
<blockquote>
<p>sockfd 指定接收端套接字描述符；<br>buf 指明一个缓冲区，该缓冲区用来存放 recv 函数接收到的数据；<br>len 指明 buf 的长度；<br>flags 一般置 0。</p>
</blockquote>
</blockquote>
<h3 id="recvfrom-函数-amp-amp-sendto-函数"><a href="#recvfrom-函数-amp-amp-sendto-函数" class="headerlink" title="recvfrom 函数 &amp;&amp; sendto 函数"></a>recvfrom 函数 &amp;&amp; sendto 函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">recvfrom函数</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">recvfrom通常用于无连接套接字，因为此函数可以获得发送者的地址。</span><br><span class="line">src_addr 是一个<span class="keyword">struct</span> <span class="title class_">sockaddr</span>类型的变量，该变量保存源机的IP地址及端口号。</span><br><span class="line">addrlen 常置为<span class="keyword">sizeof</span> （<span class="keyword">struct</span> <span class="title class_">sockaddr</span>）。</span><br><span class="line"></span><br><span class="line">sendto函数</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sendto和send相似，区别在于sendto允许在无连接的套接字上指定一个目标地址。</span><br><span class="line">dest_addr 表示目地机的IP地址和端口号信息，</span><br><span class="line">addrlen 常常被赋值为<span class="keyword">sizeof</span> （<span class="keyword">struct</span> <span class="title class_">sockaddr</span>）。</span><br><span class="line">sendto 函数也返回实际发送的数据字节长度或在出现发送错误时返回<span class="number">-1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP-程序"><a href="#TCP-程序" class="headerlink" title="TCP 程序"></a>TCP 程序</h2><p><span id="inline-red"> client.c </span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket</span></span><br><span class="line"><span class="comment"> * connect</span></span><br><span class="line"><span class="comment"> * send/recv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iSocketClient;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iRet;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ucSendBuf[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> iSendLen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &lt;server_ip&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iSocketClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	tSocketServerAddr.sin_family      = AF_INET;</span><br><span class="line">	tSocketServerAddr.sin_port        = <span class="built_in">htons</span>(SERVER_PORT);  <span class="comment">/* host to net, short */</span></span><br><span class="line"> 	<span class="comment">//tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">inet_aton</span>(argv[<span class="number">1</span>], &amp;tSocketServerAddr.sin_addr))</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid server_ip\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	iRet = <span class="built_in">connect</span>(iSocketClient, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fgets</span>(ucSendBuf, <span class="number">999</span>, stdin))</span><br><span class="line">		&#123;</span><br><span class="line">			iSendLen = <span class="built_in">send</span>(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (iSendLen &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(iSocketClient);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-red"> server.c </span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket</span></span><br><span class="line"><span class="comment"> * bind</span></span><br><span class="line"><span class="comment"> * listen</span></span><br><span class="line"><span class="comment"> * accept</span></span><br><span class="line"><span class="comment"> * send/recv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG     10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iSocketServer;</span><br><span class="line">	<span class="type">int</span> iSocketClient;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketClientAddr;</span><br><span class="line">	<span class="type">int</span> iRet;</span><br><span class="line">	<span class="type">int</span> iAddrLen;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iRecvLen;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ucRecvBuf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iClientNum = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">signal</span>(SIGCHLD,SIG_IGN);</span><br><span class="line"></span><br><span class="line">	iSocketServer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iSocketServer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tSocketServerAddr.sin_family      = AF_INET;</span><br><span class="line">	tSocketServerAddr.sin_port        = <span class="built_in">htons</span>(SERVER_PORT);  <span class="comment">/* host to net, short */</span></span><br><span class="line"> 	tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	iRet = <span class="built_in">bind</span>(iSocketServer, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iRet = <span class="built_in">listen</span>(iSocketServer, BACKLOG);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;listen error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		iAddrLen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">		iSocketClient = <span class="built_in">accept</span>(iSocketServer, (<span class="keyword">struct</span> sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> != iSocketClient)</span><br><span class="line">		&#123;</span><br><span class="line">			iClientNum++;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Get connect from client %d : %s\n&quot;</span>,  iClientNum, <span class="built_in">inet_ntoa</span>(tSocketClientAddr.sin_addr));</span><br><span class="line">			<span class="keyword">if</span> (!fork())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* �ӽ��̵�Դ�� */</span></span><br><span class="line">				<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* ���տͻ��˷��������ݲ���ʾ���� */</span></span><br><span class="line">					iRecvLen = <span class="built_in">recv</span>(iSocketClient, ucRecvBuf, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">					<span class="keyword">if</span> (iRecvLen &lt;= <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">close</span>(iSocketClient);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						ucRecvBuf[iRecvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;Get Msg From Client %d: %s\n&quot;</span>, iClientNum, ucRecvBuf);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(iSocketServer);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP-程序"><a href="#UDP-程序" class="headerlink" title="UDP 程序"></a>UDP 程序</h2><p><span id="inline-red"> client.c </span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket</span></span><br><span class="line"><span class="comment"> * connect</span></span><br><span class="line"><span class="comment"> * send/recv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iSocketClient;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iRet;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ucSendBuf[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> iSendLen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &lt;server_ip&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iSocketClient = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	tSocketServerAddr.sin_family      = AF_INET;</span><br><span class="line">	tSocketServerAddr.sin_port        = <span class="built_in">htons</span>(SERVER_PORT);  <span class="comment">/* host to net, short */</span></span><br><span class="line"> 	<span class="comment">//tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">inet_aton</span>(argv[<span class="number">1</span>], &amp;tSocketServerAddr.sin_addr))</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid server_ip\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	iRet = <span class="built_in">connect</span>(iSocketClient, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fgets</span>(ucSendBuf, <span class="number">999</span>, stdin))</span><br><span class="line">		&#123;</span><br><span class="line">			iSendLen = <span class="built_in">send</span>(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (iSendLen &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(iSocketClient);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-red"> server.c </span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket</span></span><br><span class="line"><span class="comment"> * bind</span></span><br><span class="line"><span class="comment"> * sendto/recvfrom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iSocketServer;</span><br><span class="line">	<span class="type">int</span> iSocketClient;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketClientAddr;</span><br><span class="line">	<span class="type">int</span> iRet;</span><br><span class="line">	<span class="type">int</span> iAddrLen;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iRecvLen;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ucRecvBuf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iClientNum = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	iSocketServer = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iSocketServer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tSocketServerAddr.sin_family      = AF_INET;</span><br><span class="line">	tSocketServerAddr.sin_port        = <span class="built_in">htons</span>(SERVER_PORT);  <span class="comment">/* host to net, short */</span></span><br><span class="line"> 	tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	iRet = <span class="built_in">bind</span>(iSocketServer, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		iAddrLen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">		iRecvLen = <span class="built_in">recvfrom</span>(iSocketServer, ucRecvBuf, <span class="number">999</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen);</span><br><span class="line">		<span class="keyword">if</span> (iRecvLen &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ucRecvBuf[iRecvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Get Msg From %s : %s\n&quot;</span>, <span class="built_in">inet_ntoa</span>(tSocketClientAddr.sin_addr), ucRecvBuf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(iSocketServer);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 驱动开发-3总线驱动</title>
    <url>/2022/08/10/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-3%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="linux-驱动开发-3-总线驱动"><a href="#linux-驱动开发-3-总线驱动" class="headerlink" title="linux 驱动开发-3 总线驱动"></a><div align = "center">linux 驱动开发-3 总线驱动</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-3-%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8div"><div align = "center">linux 驱动开发-3 总线驱动</div></a><ul>
<li><a href="#bus-%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6">bus 总线驱动框架</a></li>
<li><a href="#dev-%E5%92%8C-drv-%E5%8C%B9%E9%85%8D">dev 和 drv 匹配</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6">查找内核文件</a></li>
<li><a href="#bus-%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81">bus 总线驱动代码</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="bus-总线驱动框架"><a href="#bus-总线驱动框架" class="headerlink" title="bus 总线驱动框架"></a>bus 总线驱动框架</h2><div align=center><img  src ="https://pic.imgdb.cn/item/62f35c6c16f2c2beb1fca900.jpg"/></div>

<div class="note warning">
    <p>总线驱动框架分为三部分</p>
    <p>原本,资源(device),驱动(driver)</p>
    <p>将“资源”与“驱动”分离开</p>
</div>

<h2 id="dev-和-drv-匹配"><a href="#dev-和-drv-匹配" class="headerlink" title="dev 和 drv 匹配"></a>dev 和 drv 匹配</h2><div align=center><img  src ="https://pic.imgdb.cn/item/62f35dcb16f2c2beb102c9dc.jpg"/></div>

<blockquote>
<p>最先比较：platform_device. driver_override 和 platform_driver.driver.name</p>
<blockquote>
<p>可以设置 platform_device 的 driver_override，强制选择某个 platform_driver。</p>
</blockquote>
</blockquote>
<blockquote>
<p>然后比较：platform_device. name 和 platform_driver.id_table[i].name</p>
<blockquote>
<p>Platform_driver.id_table 是“platform_device_id”指针，表示该 drv 支持若干个 device，它里面列出了各个 device 的{.name, .driver_data}，其中的“name”表示该 drv 支持的设备的名字，driver_data 是些提供给该 device 的私有数据。</p>
</blockquote>
</blockquote>
<blockquote>
<p>最后比较：platform_device.name 和 platform_driver.driver.name</p>
<blockquote>
<p>platform_driver.id_table 可能为空，<br>这时可以根据 platform_driver.driver.name 来寻找同名的 platform_device。</p>
</blockquote>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">platform_device_register</span><br><span class="line">platform_device_add</span><br><span class="line">    device_add</span><br><span class="line">        bus_add_device <span class="comment">// 放入链表</span></span><br><span class="line">        bus_probe_device  <span class="comment">// probe枚举设备，即找到匹配的(dev, drv)</span></span><br><span class="line">            device_initial_probe</span><br><span class="line">                __device_attach</span><br><span class="line">                    bus<span class="constructor">_for_each_drv(<span class="operator">...</span>,<span class="params">__device_attach_driver</span>,<span class="operator">...</span>)</span></span><br><span class="line">                        __device_attach_driver</span><br><span class="line">                            driver<span class="constructor">_match_device(<span class="params">drv</span>, <span class="params">dev</span>)</span> <span class="comment">// 是否匹配</span></span><br><span class="line">                            driver_probe_device         <span class="comment">// 调用drv的probe</span></span><br><span class="line"></span><br><span class="line">platform_driver_register</span><br><span class="line">__platform_driver_register</span><br><span class="line">    driver_register</span><br><span class="line">        bus_add_driver <span class="comment">// 放入链表</span></span><br><span class="line">            driver<span class="constructor">_attach(<span class="params">drv</span>)</span></span><br><span class="line">                    bus<span class="constructor">_for_each_dev(<span class="params">drv</span>-&gt;<span class="params">bus</span>, NULL, <span class="params">drv</span>, <span class="params">__driver_attach</span>)</span>;</span><br><span class="line">                        __driver_attach</span><br><span class="line">                            driver<span class="constructor">_match_device(<span class="params">drv</span>, <span class="params">dev</span>)</span> <span class="comment">// 是否匹配</span></span><br><span class="line">                            driver_probe_device         <span class="comment">// 调用drv的probe</span></span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62f35f1116f2c2beb1085b18.jpg"/></div>

<pre class="mermaid">flowchart LR
    leddrv.c--资源-->board_A_led.c
    board_A_led.c--驱动-->chip_demo_gpio.c</pre>

<pre class="mermaid">flowchart BT
    chip_demo_gpio.c--上层-->leddrv.c
    board_A_led.c--上层-->leddrv.c

    chip_demo_gpio.c--下层-->board_A_led.c
    board_A_led.c-->chip_demo_gpio.c</pre>

<h2 id="查找内核文件"><a href="#查找内核文件" class="headerlink" title="查找内核文件"></a>查找内核文件</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">查找内核中类似的</span><br><span class="line">    <span class="keyword">grep</span> <span class="string">&quot;num_resources =&quot;</span> * -nR</span><br><span class="line"></span><br><span class="line">打开对应文件,行号</span><br><span class="line">    vi arch<span class="regexp">/blackfin/m</span>ach-bf548<span class="regexp">/boards/</span>ezkit.c +<span class="number">870</span></span><br></pre></td></tr></table></figure>

<h2 id="bus-总线驱动代码"><a href="#bus-总线驱动代码" class="headerlink" title="bus 总线驱动代码"></a>bus 总线驱动代码</h2><p><span id="inline-red"> leddrv.c </span></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号                                                                 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">class</span> *led_class;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">led_operations</span> *p_led_opr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">device_create</span>(led_class, <span class="literal">NULL</span>, <span class="built_in">MKDEV</span>(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">device_destroy</span>(led_class, <span class="built_in">MKDEV</span>(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(led_class_create_device);</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(led_class_destroy_device);</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(register_led_operations);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">led_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">char</span> status;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="built_in">file_inode</span>(file);</span><br><span class="line">	<span class="type">int</span> minor = <span class="built_in">iminor</span>(inode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	err = <span class="built_in">copy_from_user</span>(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">	p_led_opr-&gt;<span class="built_in">ctl</span>(minor, status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">led_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minor = <span class="built_in">iminor</span>(node);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">	p_led_opr-&gt;<span class="built_in">init</span>(minor);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operations结构体                                              */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> led_drv = &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = led_drv_open,</span><br><span class="line">	.read    = led_drv_read,</span><br><span class="line">	.write   = led_drv_write,</span><br><span class="line">	.release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 把file_operations结构体告诉内核：注册驱动程序                                */</span></span><br><span class="line"><span class="comment">/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">led_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	major = <span class="built_in">register_chrdev</span>(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_drv);  <span class="comment">/* /dev/led */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	led_class = <span class="built_in">class_create</span>(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line">	err = <span class="built_in">PTR_ERR</span>(led_class);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(led_class)) &#123;</span><br><span class="line">		<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="built_in">unregister_chrdev</span>(major, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数           */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">led_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">class_destroy</span>(led_class);</span><br><span class="line">	<span class="built_in">unregister_chrdev</span>(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(led_init);</span><br><span class="line"><span class="built_in">module_exit</span>(led_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-red"> board_A_led.c(资源) </span></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">led_dev_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">resource</span> resources[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .start = <span class="built_in">GROUP_PIN</span>(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .start = <span class="built_in">GROUP_PIN</span>(<span class="number">5</span>,<span class="number">8</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_device</span> board_A_led_dev = &#123;</span><br><span class="line">        .name = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">        .num_resources = <span class="built_in">ARRAY_SIZE</span>(resources),</span><br><span class="line">        .resource = resources,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">                .release = led_dev_release,</span><br><span class="line">         &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">led_dev_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">platform_device_register</span>(&amp;board_A_led_dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">led_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">platform_device_unregister</span>(&amp;board_A_led_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(led_dev_init);</span><br><span class="line"><span class="built_in">module_exit</span>(led_dev_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-red"> chip_demo_gpio.c(驱动) </span></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leddrv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledpins[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;init gpio: group %d, pin %d\n&quot;</span>, <span class="built_in">GROUP</span>(g_ledpins[which]), <span class="built_in">PIN</span>(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">GROUP</span>(g_ledpins[which]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);</span></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;set led %s: group %d, pin %d\n&quot;</span>, status ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>, <span class="built_in">GROUP</span>(g_ledpins[which]), <span class="built_in">PIN</span>(g_ledpins[which]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">GROUP</span>(g_ledpins[which]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">led_operations</span> board_demo_led_opr = &#123;</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">led_operations</span> *<span class="built_in">get_board_led_opr</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">resource</span> *res;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">platform_get_resource</span>(pdev, IORESOURCE_IRQ, i++);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        g_ledpins[g_ledcnt] = res-&gt;start;</span><br><span class="line">        <span class="built_in">led_class_create_device</span>(g_ledcnt);</span><br><span class="line">        g_ledcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">resource</span> *res;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">platform_get_resource</span>(pdev, IORESOURCE_IRQ, i);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">led_class_destroy_device</span>(i);</span><br><span class="line">        i++;</span><br><span class="line">        g_ledcnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> chip_demo_gpio_driver = &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">platform_driver_register</span>(&amp;chip_demo_gpio_driver);</span><br><span class="line">    <span class="built_in">register_led_operations</span>(&amp;board_demo_led_opr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">platform_driver_unregister</span>(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(chip_demo_gpio_drv_init);</span><br><span class="line"><span class="built_in">module_exit</span>(lchip_demo_gpio_drv_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 驱动开发-4设备树</title>
    <url>/2022/08/12/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-4%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<h1 id="linux-驱动开发-4-设备树"><a href="#linux-驱动开发-4-设备树" class="headerlink" title="linux 驱动开发-4 设备树"></a><div align = "center">linux 驱动开发-4 设备树</div></h1><!-- TOC -->

<ul>
<li><a href="#div-align--centerlinux-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-4-%E8%AE%BE%E5%A4%87%E6%A0%91div"><div align = "center">linux 驱动开发-4 设备树</div></a><ul>
<li><a href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E4%BD%9C%E7%94%A8">设备树的作用</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95">设备树语法</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F">格式</a></li>
<li><a href="#property-%E6%A0%BC%E5%BC%8F">Property 格式</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7">常用的属性</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%AE%E6%94%B9">设备树修改</a></li>
<li><a href="#%E7%BC%96%E8%AF%91-dtb-%E6%96%87%E4%BB%B6">编译 dtb 文件</a></li>
<li><a href="#%E6%9D%BF%E5%AD%90%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%A0%91">板子启动后查看设备树</a></li>
<li><a href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E5%A4%84%E7%90%86">内核对设备树的处理</a></li>
<li><a href="#dtb-%E4%B8%AD%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E9%83%BD%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA-device_node-%E7%BB%93%E6%9E%84%E4%BD%93">dtb 中每一个节点都被转换为 device_node 结构体</a></li>
<li><a href="#platform_device-%E4%B8%8E-platform_driver-%E9%85%8D%E5%AF%B9">platform_device 与 platform_driver 配对</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E8%BD%AC%E6%8D%A2%E4%B8%BA-platform_device-%E7%9A%84%E8%8A%82%E7%82%B9%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">没有转换为 platform_device 的节点使用方法</a></li>
<li><a href="#platform_device-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0">platform_device 相关的函数</a></li>
<li><a href="#%E6%9C%89%E4%BA%9B%E8%8A%82%E7%82%B9%E4%B8%8D%E4%BC%9A%E7%94%9F%E6%88%90-platform_device%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E5%AE%83%E4%BB%AC">有些节点不会生成 platform_device，怎么访问它们</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="设备树的作用"><a href="#设备树的作用" class="headerlink" title="设备树的作用"></a>设备树的作用</h2><div class="note danger">
    <p>在之前的linux发展中,内核中有ARM板保存有大量的、没有技术含量的文件</p>
    <p>于是，Linux内核开始引入设备树。设备树并不是重新发明出来的，在Linux内核中其他平台如PowerPC，早就使用设备树来描述硬件了</p>
</div>

<h2 id="设备树语法"><a href="#设备树语法" class="headerlink" title="设备树语法"></a>设备树语法</h2><div align=center><img  src ="https://pic.imgdb.cn/item/62f65d8e16f2c2beb10b0d4f.jpg"/></div>

<blockquote>
<p>我们需要编写设备树文件(dts: device tree source)，它需要编译为 dtb(device tree blob)文件，内核使用的是 dtb 文件。<br>dts 文件是根本</p>
</blockquote>
<div align=center><img  src ="https://pic.imgdb.cn/item/62f65dd716f2c2beb10c4f29.jpg"/></div>

<p><span id="inline-yellow"> dts 文件如下 </span></p>
<div align=center><img  src ="https://pic.imgdb.cn/item/62f65e2716f2c2beb10deca8.jpg"/></div>

<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><span id="inline-yellow"> DTS 文件的格式 </span></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">DTS文件布局(layout):</span><br><span class="line"><span class="keyword">/dts-v1/</span><span class="punctuation">;</span>                <span class="comment">// 表示版本</span></span><br><span class="line">[memory reservations]    <span class="comment">// 格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;</span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line">    [property definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p><span id="inline-yellow"> node 的格式 </span></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">设备树中的基本单元，被称为“<span class="keyword">node</span><span class="title">”，其格式为：</span></span><br><span class="line"><span class="title">[label</span>:] <span class="keyword">node</span><span class="title">-name</span>[@unit-address] &#123;</span><br><span class="line">    [properties definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">label是标号，可以省略。label的作用是为了方便地引用<span class="keyword">node</span><span class="title">，比如：</span></span><br><span class="line"><span class="title">/dts-v1</span>/;</span><br><span class="line">/ &#123;</span><br><span class="line">	uart0: uart@fe001000 &#123;</span><br><span class="line">        <span class="attr">compatible=</span><span class="string">&quot;ns16550&quot;</span>;</span><br><span class="line">        <span class="attr">reg=</span><span class="tag">&lt;0xfe001000 0x100&gt;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">可以使用下面<span class="number">2</span>种方法来修改uart@fe001000这个<span class="keyword">node</span><span class="title">：</span></span><br><span class="line"><span class="title">// 在根节点之外使用label</span>引用<span class="keyword">node</span><span class="title">：</span></span><br><span class="line"><span class="title">&amp;uart0</span> &#123;</span><br><span class="line">    status = “disabled”;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">或在根节点之外使用全路径：</span><br><span class="line">&amp;&#123;/uart@fe001000&#125;  &#123;</span><br><span class="line">    status = “disabled”;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Property-格式"><a href="#Property-格式" class="headerlink" title="Property 格式"></a>Property 格式</h2><p>value 有多种取值方式</p>
<blockquote>
<p>a. Arrays of cells : cell 就是一个 32 位的数据，用尖括号包围起来</p>
<blockquote>
<p>interrupts &#x3D; &lt;17 0xc&gt;;</p>
</blockquote>
</blockquote>
<blockquote>
<p>b. 64bit 数据使用 2 个 cell 来表示，用尖括号包围起来:</p>
<blockquote>
<p>clock-frequency &#x3D; &lt;0x00000001 0x00000000&gt;;</p>
</blockquote>
</blockquote>
<blockquote>
<p>c. A null-terminated string (有结束符的字符串)，用双引号包围起来:</p>
<blockquote>
<p>compatible &#x3D; “simple-bus”;</p>
</blockquote>
</blockquote>
<blockquote>
<p>d. A bytestring(字节序列) ，用中括号包围起来:</p>
<blockquote>
<p>local-mac-address &#x3D; [00 00 12 34 56 78]; &#x2F;&#x2F; 每个 byte 使用 2 个 16 进制数来表示<br>local-mac-address &#x3D; [000012345678]; &#x2F;&#x2F; 每个 byte 使用 2 个 16 进制数来表示</p>
</blockquote>
</blockquote>
<blockquote>
<p>e. 可以是各种值的组合, 用逗号隔开:</p>
<blockquote>
<p>compatible &#x3D; “ns16550”, “ns8250”;<br>example &#x3D; &lt;0xf00f0000 19&gt;, “a strange property format”;</p>
</blockquote>
</blockquote>
<h2 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h2><p><span id="inline-yellow"> #address-cells、#size-cells </span></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cell</span>指一个<span class="number">32</span>位的数值，</span><br><span class="line"><span class="attribute">address</span>-cells：address要用多少个<span class="number">32</span>位数来表示；</span><br><span class="line"><span class="attribute">size</span>-cells：size要用多少个<span class="number">32</span>位数来表示。</span><br></pre></td></tr></table></figure>

<p>例中，address-cells 为 1，所以 reg 中用 1 个数来表示地址，即用 0x80000000 来表示地址；size-cells 为 1，所以 reg 中用 1 个数来表示大小，即用 0x20000000 表示大小：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="title class_">memory</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x20000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-yellow"> compatible </span></p>
<p>“compatible”表示“兼容”，对于某个 LED，内核中可能有 A、B、C 三个驱动都支持它，那可以这样写：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">led &#123;</span><br><span class="line">compatible = “<span class="keyword">A</span>”, “B”, “C”<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内核启动时，就会为这个 LED 按这样的优先顺序为它找到驱动程序：A、B、C。</p>
</blockquote>
<blockquote>
<p>根节点下也有 compatible 属性，用来选择哪一个“machine desc”：一个内核可以支持 machine A，也支持 machine B，内核启动后会根据根节点的 compatible 属性找到对应的 machine desc 结构体，执行其中的初始化函数。<br>compatible 的值，建议取这样的形式：”manufacturer,model”，即“厂家名,模块名”</p>
</blockquote>
<p><span id="inline-yellow"> model </span></p>
<p>model 属性与 compatible 属性有些类似，但是有差别。<br>compatible 属性是一个字符串列表，表示可以你的硬件兼容 A、B、C 等驱动；<br>model 用来准确地定义这个硬件是什么。<br>比如根节点中可以这样写：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;samsung,smdk2440&quot;</span>, <span class="string">&quot;samsung,mini2440&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;jz2440_v3&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>它表示这个单板，可以兼容内核中的“smdk2440”，也兼容“mini2440”。<br>从 compatible 属性中可以知道它兼容哪些板，但是它到底是什么板？用 model 属性来明确</p>
</blockquote>
<p><span id="inline-yellow"> status </span></p>
<p>dtsi 文件中定义了很多设备，但是在你的板子上某些设备是没有的。这时你可以给这个设备节点添加一个 status 属性，设置为“disabled”：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">&amp;<span class="keyword">uart1</span> &#123;</span><br><span class="line">      <span class="literal">status</span> = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div align=center><img  src ="https://pic.imgdb.cn/item/62f660ec16f2c2beb11acb34.jpg"/></div>

<p><span id="inline-yellow"> reg </span></p>
<p>reg 的本意是 register，用来表示寄存器地址。<br>但是在设备树里，它可以用来描述一段空间。反正对于 ARM 系统，寄存器和内存是统一编址的，即访问寄存器时用某块地址，访问内存时用某块地址，在访问方法上没有区别。<br>reg 属性的值，是一系列的“address size”，用多少个 32 位的数来表示 address 和 size，由其父节点的#address-cells、#size-cells 决定。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="keyword">/dts-v1/</span><span class="punctuation">;</span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="title class_">memory</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x80000000</span> <span class="number">0x20000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="设备树修改"><a href="#设备树修改" class="headerlink" title="设备树修改"></a>设备树修改</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="number">100</span><span class="title class_">ask_led@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;100as,leddrv&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pin</span> <span class="operator">=</span> <span class="params">&lt;GROUP_PIN(<span class="number">3</span>, <span class="number">1</span>)&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">	<span class="number">100</span><span class="title class_">ask_led@1</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;100as,leddrv&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pin</span> <span class="operator">=</span> <span class="params">&lt;GROUP_PIN(<span class="number">5</span>, <span class="number">8</span>)&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span id="inline-yellow"> 驱动 </span></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leddrv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledpins[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;init gpio: group %d, pin %d\n&quot;</span>, <span class="built_in">GROUP</span>(g_ledpins[which]), <span class="built_in">PIN</span>(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">GROUP</span>(g_ledpins[which]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;init pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);</span></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;set led %s: group %d, pin %d\n&quot;</span>, status ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>, <span class="built_in">GROUP</span>(g_ledpins[which]), <span class="built_in">PIN</span>(g_ledpins[which]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">GROUP</span>(g_ledpins[which]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;set pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">led_operations</span> board_demo_led_opr = &#123;</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">led_operations</span> *<span class="built_in">get_board_led_opr</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device_node</span> *np;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">of_property_read_u32</span>(np, <span class="string">&quot;pin&quot;</span>, &amp;led_pin);</span><br><span class="line"></span><br><span class="line">    g_ledpins[g_ledcnt] = led_pin;</span><br><span class="line">    <span class="built_in">led_class_create_device</span>(g_ledcnt);</span><br><span class="line">    g_ledcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device_node</span> *np;</span><br><span class="line">    <span class="type">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">of_property_read_u32</span>(np, <span class="string">&quot;pin&quot;</span>, &amp;led_pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_ledcnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_ledpins[i] == led_pin)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">led_class_destroy_device</span>(i);</span><br><span class="line">            g_ledpins[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_ledcnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_ledpins[i] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == g_ledcnt)</span><br><span class="line">        g_ledcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> ask100_leds[] = &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100as,leddrv&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> chip_demo_gpio_driver = &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_leds,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">platform_driver_register</span>(&amp;chip_demo_gpio_driver);</span><br><span class="line">    <span class="built_in">register_led_operations</span>(&amp;board_demo_led_opr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">platform_driver_unregister</span>(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(chip_demo_gpio_drv_init);</span><br><span class="line"><span class="built_in">module_exit</span>(lchip_demo_gpio_drv_exit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译-dtb-文件"><a href="#编译-dtb-文件" class="headerlink" title="编译 dtb 文件"></a>编译 dtb 文件</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">make  dtbs  <span class="attribute">V</span>=1</span><br></pre></td></tr></table></figure>

<p>设备树文件是：内核源码目录中 arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;100ask_imx6ul_qemu.dtb<br>它是执行 qemu 时直接在命令行中指定设备树文件的，你可以打开脚本文件 qemu-imx6ul-gui.sh 找到 dtb 文件的位置，然后使用新编译出来的 dtb 去覆盖老文件。</p>
<h2 id="板子启动后查看设备树"><a href="#板子启动后查看设备树" class="headerlink" title="板子启动后查看设备树"></a>板子启动后查看设备树</h2><p>板子启动后执行下面的命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"> ls <span class="regexp">/sys/</span>firmware/</span><br><span class="line">devicetree  fdt</span><br></pre></td></tr></table></figure>

<p>&#x2F;sys&#x2F;firmware&#x2F;devicetree 目录下是以目录结构程现的 dtb 文件, 根节点对应 base 目录, 每一个节点对应一个目录, 每一个属性对应一个文件。<br>这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；对于数值，可以用 hexdump 把它打印出来。</p>
<h2 id="内核对设备树的处理"><a href="#内核对设备树的处理" class="headerlink" title="内核对设备树的处理"></a>内核对设备树的处理</h2><p>从源代码文件 dts 文件开始，设备树的处理过程为：</p>
<div align=center><img  src ="https://pic.imgdb.cn/item/62f662e716f2c2beb123712c.jpg"/></div>

<p>① dts 在 PC 机上被编译为 dtb 文件；<br>② u-boot 把 dtb 文件传给内核；<br>③ 内核解析 dtb 文件，把每一个节点都转换为 device_node 结构体；<br>④ 对于某些 device_node 结构体，会被转换为 platform_device 结构体。</p>
<h2 id="dtb-中每一个节点都被转换为-device-node-结构体"><a href="#dtb-中每一个节点都被转换为-device-node-结构体" class="headerlink" title="dtb 中每一个节点都被转换为 device_node 结构体"></a>dtb 中每一个节点都被转换为 device_node 结构体</h2><div align=center><img  src ="https://pic.imgdb.cn/item/62f6639316f2c2beb1263d58.jpg"/></div>
根节点被保存在全局变量of_root中，从of_root开始可以访问到任意节点。

<p>哪些设备树节点会被转换为 platform_device</p>
<blockquote>
<p>A. 根节点下含有 compatile 属性的子节点</p>
</blockquote>
<blockquote>
<p>B. 含有特定 compatile 属性的节点的子节点</p>
<blockquote>
<p>如果一个节点的 compatile 属性，它的值是这 4 者之一：”simple-bus”,”simple-mfd”,”isa”,”arm,amba-bus”,<br>那么它的子结点(需含 compatile 属性)也可以转换为 platform_device。</p>
</blockquote>
</blockquote>
<blockquote>
<p>C. 总线 I2C、SPI 节点下的子节点：不转换为 platform_device</p>
<blockquote>
<p>某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为 platform_device。</p>
</blockquote>
</blockquote>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">比如以下的节点中：</span><br><span class="line">/mytest会被转换为platform_device, 因为它兼容<span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line">它的子节点<span class="keyword">/mytest/</span>mytest@<span class="number">0</span> 也会被转换为platform_device</span><br><span class="line">/i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_<span class="attr">driver</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">/i2c/</span>at24c02节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个i2c_client。</span><br><span class="line">类似的也有/spi节点, 它一般也是用来表示SPI控制器, 它会被转换为platform_device, 在内核中有对应的platform_<span class="attr">driver</span><span class="punctuation">;</span></span><br><span class="line"><span class="keyword">/spi/</span>flash@<span class="number">0</span>节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个spi_device。</span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line">	  <span class="title class_">mytest</span> <span class="punctuation">&#123;</span></span><br><span class="line">		  <span class="attr">compatile</span> <span class="operator">=</span> <span class="string">&quot;mytest&quot;</span>, <span class="string">&quot;simple-bus&quot;</span><span class="punctuation">;</span></span><br><span class="line">		  <span class="title class_">mytest@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">compatile</span> <span class="operator">=</span> <span class="string">&quot;mytest_0&quot;</span><span class="punctuation">;</span></span><br><span class="line">		  <span class="punctuation">&#125;;</span></span><br><span class="line">	  <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">	  <span class="title class_">i2c</span> <span class="punctuation">&#123;</span></span><br><span class="line">		  <span class="attr">compatile</span> <span class="operator">=</span> <span class="string">&quot;samsung,i2c&quot;</span><span class="punctuation">;</span></span><br><span class="line">		  <span class="title class_">at24c02</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">compatile</span> <span class="operator">=</span> <span class="string">&quot;at24c02&quot;</span><span class="punctuation">;</span></span><br><span class="line">		  <span class="punctuation">&#125;;</span></span><br><span class="line">	  <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">	  <span class="title class_">spi</span> <span class="punctuation">&#123;</span></span><br><span class="line">		  <span class="attr">compatile</span> <span class="operator">=</span> <span class="string">&quot;samsung,spi&quot;</span><span class="punctuation">;</span></span><br><span class="line">		  <span class="title class_">flash@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;winbond,w25q32dw&quot;</span><span class="punctuation">;</span></span><br><span class="line">				<span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">25000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">				<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">			  <span class="punctuation">&#125;;</span></span><br><span class="line">	  <span class="punctuation">&#125;;</span></span><br><span class="line">  <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么转换为 platform_device<br>内核处理设备树的函数调用过程，这里不去分析；我们只需要得到如下结论：</p>
<blockquote>
<p>A. platform_device 中含有 resource 数组, 它来自 device_node 的 reg, interrupts 属性;<br>B. platform_device.dev.of_node 指向 device_node, 可以通过它获得其他属性</p>
</blockquote>
</blockquote>
<h2 id="platform-device-与-platform-driver-配对"><a href="#platform-device-与-platform-driver-配对" class="headerlink" title="platform_device 与 platform_driver 配对"></a>platform_device 与 platform_driver 配对</h2><div class="note warning"><p>
从设备树转换得来的platform_device会被注册进内核里，以后当我们每注册一个platform_driver时，它们就会两两确定能否配对，如果能配对成功就调用platform_driver的probe函数。</p></div>

<div align=center><img  src ="https://pic.imgdb.cn/item/62f6650f16f2c2beb12c6f9f.jpg"/></div>

<blockquote>
<p>最先比较：是否强制选择某个 driver</p>
<blockquote>
<p>比较 platform_device. driver_override 和 platform_driver.driver.name<br>可以设置 platform_device 的 driver_override，强制选择某个 platform_driver。</p>
</blockquote>
</blockquote>
<blockquote>
<p>然后比较：设备树信息</p>
<blockquote>
<p>比较：platform_device. dev.of_node 和 platform_driver.driver.of_match_table。</p>
</blockquote>
</blockquote>
<p>由设备树节点转换得来的 platform_device 中，含有一个结构体：of_node。<br>它的类型如下：</p>
<div align=center><img  src ="https://pic.imgdb.cn/item/62f6665416f2c2beb131c49d.jpg"/></div>

<p>如果一个 platform_driver 支持设备树，它的 platform_driver.driver.of_match_table 是一个数组，类型如下：</p>
 <div align=center><img  src ="https://pic.imgdb.cn/item/62f6666416f2c2beb132063d.jpg"/></div>

<p>使用设备树信息来判断 dev 和 drv 是否配对时，<br>首先，如果 of_match_table 中含有 compatible 值，就跟 dev 的 compatile 属性比较，若一致则成功，否则返回失败；<br>其次，如果 of_match_table 中含有 type 值，就跟 dev 的 device_type 属性比较，若一致则成功，否则返回失败；<br>最后，如果 of_match_table 中含有 name 值，就跟 dev 的 name 属性比较，若一致则成功，否则返回失败。</p>
<p>而设备树中建议不再使用 devcie_type 和 name 属性，所以基本上只使用设备节点的 compatible 属性来寻找匹配的 platform_driver。</p>
<blockquote>
<p>接下来比较：platform_device_id</p>
<blockquote>
<p>比较 platform_device. name 和 platform_driver.id_table[i].name，id_table 中可能有多项。<br>platform_driver.id_table 是“platform_device_id”指针，表示该 drv 支持若干个 device，它里面列出了各个 device 的{.name, .driver_data}，其中的“name”表示该 drv 支持的设备的名字，driver_data 是些提供给该 device 的私有数据。</p>
</blockquote>
</blockquote>
<blockquote>
<p>最后比较：platform_device.name 和 platform_driver.driver.name</p>
<blockquote>
<p>platform_driver.id_table 可能为空，<br>这时可以根据 platform_driver.driver.name 来寻找同名的 platform_device。</p>
</blockquote>
</blockquote>
 <div align=center><img  src ="https://pic.imgdb.cn/item/62f666a316f2c2beb13311bc.jpg"/></div>

<h2 id="没有转换为-platform-device-的节点使用方法"><a href="#没有转换为-platform-device-的节点使用方法" class="headerlink" title="没有转换为 platform_device 的节点使用方法"></a>没有转换为 platform_device 的节点使用方法</h2><blockquote>
<p>任意驱动程序里，都可以直接访问设备树。<br>你可以使用函数找到节点，读出里面的值</p>
</blockquote>
<p>内核里操作设备树的常用函数<br>内核源码中 include&#x2F;linux&#x2F;目录下有很多 of 开头的头文件，of 表示“open firmware”即开放固件。</p>
<blockquote>
<p>内核中设备树相关的头文件介绍</p>
<blockquote>
<p>设备树的处理过程是：dtb -&gt; device_node -&gt; platform_device。</p>
</blockquote>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">处理DTB</span><br><span class="line">of_fdt.h           <span class="regexp">//</span> dtb文件的相关操作函数, 我们一般用不到,</span><br><span class="line"><span class="regexp">//</span> 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">处理device_node</span><br><span class="line">of.h               <span class="regexp">//</span> 提供设备树的一般处理函数,</span><br><span class="line"><span class="regexp">//</span> 比如 of_property_read_u32(读取某个属性的u32值),</span><br><span class="line"><span class="regexp">//</span> of_get_child_count(获取某个device_node的子节点数)</span><br><span class="line">of_address.h       <span class="regexp">//</span> 地址相关的函数,</span><br><span class="line"><span class="regexp">//</span> 比如 of_get_address(获得reg属性中的addr, size值)</span><br><span class="line"><span class="regexp">//</span> of_match_device (从matches数组中取出与当前设备最匹配的一项)</span><br><span class="line">of_dma.h           <span class="regexp">//</span> 设备树中DMA相关属性的函数</span><br><span class="line">of_gpio.h          <span class="regexp">//</span> GPIO相关的函数</span><br><span class="line">of_graph.h         <span class="regexp">//</span> GPU相关驱动中用到的函数, 从设备树中获得GPU信息</span><br><span class="line">of_iommu.h         <span class="regexp">//</span> 很少用到</span><br><span class="line">of_irq.h           <span class="regexp">//</span> 中断相关的函数</span><br><span class="line">of_mdio.h          <span class="regexp">//</span> MDIO (Ethernet PHY) API</span><br><span class="line">of_net.h           <span class="regexp">//</span> OF helpers <span class="keyword">for</span> network devices.</span><br><span class="line">of_pci.h           <span class="regexp">//</span> PCI相关函数</span><br><span class="line">of_pdt.h           <span class="regexp">//</span> 很少用到</span><br><span class="line">of_reserved_mem.h  <span class="regexp">//</span> reserved_mem的相关函数</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">处理 platform_device</span><br><span class="line">of_platform.h      <span class="regexp">//</span> 把device_node转换为platform_device时用到的函数,</span><br><span class="line">                   <span class="regexp">//</span> 比如of_device_alloc(根据device_node分配设置platform_device),</span><br><span class="line">                   <span class="regexp">//</span> of_find_device_by_node (根据device_node查找到platform_device),</span><br><span class="line">                   <span class="regexp">//</span>   of_platform_bus_probe (处理device_node及它的子节点)</span><br><span class="line">of_device.h        <span class="regexp">//</span> 设备相关的函数, 比如 of_match_device</span><br></pre></td></tr></table></figure>

<h2 id="platform-device-相关的函数"><a href="#platform-device-相关的函数" class="headerlink" title="platform_device 相关的函数"></a>platform_device 相关的函数</h2><p>of_platform.h 中声明了很多函数，但是作为驱动开发者，我们只使用其中的 1、2 个。其他的都是给内核自己使用的，内核使用它们来处理设备树，转换得到 platform_device。</p>
<blockquote>
<p>of_find_device_by_node</p>
<blockquote>
<p>函数原型为：<br>extern struct platform_device *of_find_device_by_node(struct device_node *np);</p>
</blockquote>
</blockquote>
<p>设备树中的每一个节点，在内核里都有一个 device_node；你可以使用 device_node 去找到对应的 platform_device。</p>
<blockquote>
<p>platform_get_resource</p>
<blockquote>
<p>这个函数跟设备树没什么关系，但是设备树中的节点被转换为 platform_device 后，设备树中的 reg 属性、interrupts 属性也会被转换为“resource”。<br>这时，你可以使用这个函数取出这些资源。</p>
</blockquote>
</blockquote>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">函数原型为：</span><br><span class="line">/**</span><br><span class="line"> * platform_get_resource - <span class="built_in">get</span> a resource for a device</span><br><span class="line"> * @<span class="built_in">dev</span>: platform device</span><br><span class="line"> * @<span class="built_in">type</span>: resource <span class="built_in">type</span>   <span class="comment">// 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG</span></span><br><span class="line"> *                      <span class="comment">// IORESOURCE_IRQ等</span></span><br><span class="line"> * @num: resource index  <span class="comment">// 这类资源中的哪一个？</span></span><br><span class="line"> */</span><br><span class="line">struct resource *platform_get_resource(struct platform_device *<span class="built_in">dev</span>,</span><br><span class="line">				       unsigned <span class="type">int</span> <span class="built_in">type</span>, unsigned <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">对于设备树节点中的reg属性，它对应IORESOURCE_MEM类型的资源；</span><br><span class="line">对于设备树节点中的interrupts属性，它对应IORESOURCE_IRQ类型的资源。</span><br></pre></td></tr></table></figure>

<h2 id="有些节点不会生成-platform-device，怎么访问它们"><a href="#有些节点不会生成-platform-device，怎么访问它们" class="headerlink" title="有些节点不会生成 platform_device，怎么访问它们"></a>有些节点不会生成 platform_device，怎么访问它们</h2><p>内核会把 dtb 文件解析出一系列的 device_node 结构体，我们可以直接访问这些 device_node。<br>内核源码 incldue&#x2F;linux&#x2F;of.h 中声明了 device_node 和属性 property 的操作函数，device_node 和 property 的结构体</p>
<div align=center><img  src ="https://pic.imgdb.cn/item/62f6639316f2c2beb1263d58.jpg"/></div>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *np;</span><br><span class="line">    <span class="built_in">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)</span><br><span class="line">        return -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    err = <span class="keyword">of</span><span class="constructor">_property_read_u32(<span class="params">np</span>, <span class="string">&quot;pin&quot;</span>, &amp;<span class="params">led_pin</span>)</span>;</span><br><span class="line"></span><br><span class="line">调用of_property_read_u32 <span class="literal">()</span>时，led_pin将得到值；</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>更多函数位于 11.7</p></div>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux-驱动开发</tag>
      </tags>
  </entry>
  <entry>
    <title>msp430笔记——io口</title>
    <url>/2022/06/20/msp430%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94io%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="msp430-笔记——io-口"><a href="#msp430-笔记——io-口" class="headerlink" title="msp430 笔记——io 口"></a>msp430 笔记——io 口</h1><!-- TOC -->

<ul>
<li><a href="#msp430-%E7%AC%94%E8%AE%B0io-%E5%8F%A3">msp430 笔记——io 口</a><ul>
<li><a href="#1io-%E5%8F%A3%E7%B1%BB%E5%9E%8B">1、io 口类型</a></li>
<li><a href="#2io-%E5%8F%A3%E5%AF%84%E5%AD%98%E5%99%A8">2、io 口寄存器</a></li>
<li><a href="#3%E6%8C%89%E9%94%AE-led-%E5%AE%9E%E9%AA%8C">3、按键 led 实验</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="1、io-口类型"><a href="#1、io-口类型" class="headerlink" title="1、io 口类型"></a>1、io 口类型</h2><ul>
<li>可独立编程的 I&#x2F;O 管脚</li>
<li>输入或输出可任意组合</li>
<li>可独立设置的 P1 和 P2 中断，某些器件可能还有其他中断口 39、独立的输入、输出数据寄存器</li>
<li>可独立配置的上拉或下拉电阻</li>
</ul>
<p>其中只有 P1 和 P2 有中断能力，所有 P1 口的 I&#x2F;O 管脚中断都来源于**<em>同一个</em>**中断向量 P1IV，</p>
<p>​ 而所有 P2 口的中断都来源于**<em>不同的单一</em>**中断向量 P2IV。</p>
<h2 id="2、io-口寄存器"><a href="#2、io-口寄存器" class="headerlink" title="2、io 口寄存器"></a>2、io 口寄存器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入寄存器——PxIN</span><br><span class="line">	例：P1IN P2IN...</span><br><span class="line">	   判断按键按下——<span class="keyword">if</span>((P1IN &amp; BIT1)==<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输出寄存器——PxOUT</span><br><span class="line">	例：P1OUT P2OUT...</span><br><span class="line">	   输出高低电平——P1OUT <span class="meta">&amp;= ~BIT0 （低）</span></span><br><span class="line">	   			   P1OUT <span class="string">|= BIT1  （高）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入/输出方向寄存器——PxDIR</span><br><span class="line">	不论管脚的功能，PxDIR 寄存器中的每一位选择相应 I/O 管脚的方向。当管脚被设置为其它功能	时，PxDIR 位必须按照其他功能的需要进行设置。</span><br><span class="line"></span><br><span class="line">	Bit = <span class="number">0</span>：管脚为输入方向</span><br><span class="line">	Bit = <span class="number">1</span>：管脚为输出方向</span><br><span class="line"></span><br><span class="line">	所以，输出应该这样：		P1DIR <span class="string">|= BIT0;</span></span><br><span class="line">  						  P1OUT <span class="meta">&amp;= ~BIT0;</span></span><br><span class="line"></span><br><span class="line">         输入应该这样：	  P1DIR <span class="meta">&amp;= ~BIT1;</span></span><br><span class="line">                          P1REN <span class="string">|= BIT1;</span></span><br><span class="line">                          P1OUT <span class="string">|= BIT1;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">上拉/下拉电阻能寄存器——PxREN</span><br><span class="line">    PxREN 寄存器中的每一位可以使能/禁止相应 I/O 管脚的上拉/下拉电阻。</span><br><span class="line">    PxOUT 寄存器中对应的位选择管脚是否包含上拉或下拉电阻。</span><br><span class="line"></span><br><span class="line">    Bit <span class="operator">=</span> <span class="number">0</span>：上拉、下拉寄存器禁止</span><br><span class="line">    Bit <span class="operator">=</span> <span class="number">1</span>：上拉、下拉寄存器使能</span><br><span class="line"></span><br><span class="line">    输出不需要上拉电阻或下拉电阻，所以不需要设置</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>PxDIR</th>
<th>PxREN</th>
<th>PxOUT</th>
<th>I&#x2F;O 口配置</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>x</td>
<td>输入</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>下拉输入</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>上拉输入</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>x</td>
<td>输出</td>
</tr>
</tbody></table>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输出驱动能力增强寄存器——PxDS</span><br><span class="line">	PxDS 寄存器的每一位选择全驱动或弱驱动。默认的是弱驱动能力。</span><br><span class="line"></span><br><span class="line">	Bit <span class="operator">=</span> <span class="number">0</span>：弱驱动</span><br><span class="line">	Bit <span class="operator">=</span> <span class="number">1</span>：全驱动</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">功能选择寄存器——<span class="variable">PxSEL</span></span><br><span class="line">	端口管脚经常与其他外围模块复用，参考芯片数据手册确定管脚功能。每个<span class="variable">PxSEL</span> 位选择对应管脚	  的功能——普通 <span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span> 功能或外围模块功能。</span><br><span class="line"></span><br><span class="line">	<span class="variable">Bit</span> <span class="operator">=</span> <span class="number">0</span>：<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span> 口功能</span><br><span class="line">	<span class="variable">Bit</span> <span class="operator">=</span> <span class="number">1</span>：外围模块功能</span><br><span class="line"></span><br><span class="line">	（注意）当<span class="variable">PxSEL</span><span class="operator">=</span><span class="number">1</span>时，禁止<span class="variable">P1</span>和<span class="variable">P2</span>口的中断功能</span><br><span class="line">		置位任何<span class="variable">PxSEL</span>位，将禁止相应管脚的<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>口中断功能。因此，无论相应<span class="variable">P1IE</span>和<span class="variable">P2IE</span>寄存			器状态如何，这些管脚的信号不能产生<span class="variable">P1</span>或<span class="variable">P2</span>口中断。</span><br></pre></td></tr></table></figure>

<h2 id="3、按键-led-实验"><a href="#3、按键-led-实验" class="headerlink" title="3、按键 led 实验"></a>3、按键 led 实验</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> time)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;time&gt;<span class="number">0</span>;time--)</span><br><span class="line">        __delay_cycles(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  WDTCTL = WDTPW | WDTHOLD;                   <span class="comment">//关闭看门狗</span></span><br><span class="line">  P1DIR |= BIT0;                              <span class="comment">//设置P1.0为输出</span></span><br><span class="line">  P1OUT &amp;= ~BIT0;                             <span class="comment">//P1.0低电平</span></span><br><span class="line"></span><br><span class="line">  P1DIR &amp;= ~BIT1;                             <span class="comment">//设置P1.1为输入</span></span><br><span class="line">  P1REN |= BIT1;                              <span class="comment">//上拉电阻输入</span></span><br><span class="line">  P1OUT |= BIT1;                              <span class="comment">//设置P1.1为高电平状态</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>((P1IN &amp; BIT1)==<span class="number">0</span>)&#123;                   <span class="comment">//检测S1按下 P1.1</span></span><br><span class="line">          P1OUT ^= BIT0;                      <span class="comment">//取反P1.0的输出</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>msp430</category>
      </categories>
      <tags>
        <tag>msp430笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>msp430笔记——中断</title>
    <url>/2022/06/20/msp430%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="msp430-笔记——中断"><a href="#msp430-笔记——中断" class="headerlink" title="msp430 笔记——中断"></a>msp430 笔记——中断</h1><!-- TOC -->

<ul>
<li><a href="#msp430-%E7%AC%94%E8%AE%B0%E4%B8%AD%E6%96%AD">msp430 笔记——中断</a><ul>
<li><a href="#1io-%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96">1、i&#x2F;o 中断初始化</a></li>
<li><a href="#2%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD">2、定时器中断</a><ul>
<li><a href="#1%E6%AF%94%E8%BE%83">1、比较</a></li>
<li><a href="#2%E6%8D%95%E8%8E%B7">2、捕获</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<span id="more"></span>

<h2 id="1、i-x2F-o-中断初始化"><a href="#1、i-x2F-o-中断初始化" class="headerlink" title="1、i&#x2F;o 中断初始化"></a>1、i&#x2F;o 中断初始化</h2><p>​ P1 和 P2 口中断，端口中断 当对 PxIFG,PxIE 及 PxIES 寄存器进行相应的配置后，P1 和 P2 口的每一个管 脚都可具备中断能力。</p>
<p>​ 所有 P1 口中断标志是有优先级的，如 P1IFG.0 具有最高 优先级，它们组合共用一个中断向量。使能的具有最高优先级中断在 P1IV 中产 生 1 个数值。为了跳转到适当的程序位置，对该数值评估或加到程序计数器上。 禁止 P1 口中断不会影响 P1IV 寄存器中的值。</p>
<!--more-->

<p>​ P2 口具有相同的功能。PxIV 寄 存器只能以字形式访问。</p>
<p>​ (注意)任何对 P1IV 寄存器的读写操作都会自动使最高响应优先级中断标志复位。 如果另外一个中断标志置位，则在响应最初中断后立即产生另一中断。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">PxIES——中断沿选择寄存器</span><br><span class="line">			每个 PxIES 位为相应的 I/O 管脚选择中断沿。</span><br><span class="line"> 			Bit <span class="operator">=</span> <span class="number">0</span>：上升沿时置位各自的 PxIFGx 标志</span><br><span class="line">			Bit <span class="operator">=</span> <span class="number">1</span>：下降沿时置位各自的 PxIFGx 标志</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">PXIE——中断使能寄存器</span><br><span class="line">		  	每个 PxIE 位将使能相应的 PxIFG 中断标志。</span><br><span class="line">			Bit <span class="operator">=</span> <span class="number">0</span>：Px 口中断禁止</span><br><span class="line">			Bit <span class="operator">=</span> <span class="number">1</span>：Px 口中断使能</span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">PXIFG——中断标志位</span><br><span class="line">		  	每个 PxIFGx 位都是相应 I/O 管脚的中断标志位，当管脚上有选择的输入信号沿到来			时，PxIFGx 置位。当相应的 PxIE 位和 GIE 位置位时，所有的 PxIFGx中断标志			产生中断请求。软件也可以使 PxIFG 标志置位，这就提供了一种软件产生中断的方法。</span><br><span class="line"></span><br><span class="line">			Bit <span class="operator">=</span> <span class="number">0</span>： 没有中断挂起</span><br><span class="line">			Bit <span class="operator">=</span> <span class="number">1</span>： 中断挂起</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">初始化中断：</span><br><span class="line">	P1DIR |= BIT1;	<span class="regexp">//</span>P1.<span class="number">1</span>方向为输入</span><br><span class="line">    P1REN |= BIT1;	<span class="regexp">//</span>P1.<span class="number">1</span>允许上下拉电阻</span><br><span class="line">    P1OUT |= BIT1;	<span class="regexp">//</span>P1.<span class="number">1</span>上拉电阻</span><br><span class="line"></span><br><span class="line">    P1IES |= BIT1;	<span class="regexp">//</span>下降沿中断</span><br><span class="line">    P1IE |= BIT1;	<span class="regexp">//</span>P1.<span class="number">1</span>中断允许</span><br><span class="line">    P1IFG &amp;= ~BIT1;	<span class="regexp">//</span>清除标志位</span><br></pre></td></tr></table></figure>

<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">中断函数：</span><br><span class="line">    <span class="meta">#pragma vector = PORT1_VECTOR	<span class="comment">//中断的必须写法</span></span></span><br><span class="line">    __interrupt void P1_ISR()		<span class="comment">//中断函数名称</span></span><br><span class="line">    &#123;</span><br><span class="line">        if(P1IFG <span class="meta">&amp; BIT1)&#123;			<span class="comment">//判断中断标志位</span></span></span><br><span class="line">            while((P1IN <span class="meta">&amp; BIT1) == 0);	<span class="comment">//识别按键按下</span></span></span><br><span class="line">                P1OUT <span class="string">|= BIT0;</span></span><br><span class="line">                delay(<span class="number">1000</span>);</span><br><span class="line">                P1OUT ^= BIT0;</span><br><span class="line">        &#125;</span><br><span class="line">        P1IFG <span class="meta">&amp;= ~BIT1;				<span class="comment">//清除标志位</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、定时器中断"><a href="#2、定时器中断" class="headerlink" title="2、定时器中断"></a>2、定时器中断</h2><p>​ MSP430F5529 共有两类共 4 个定时器，分别是 Timer_A 定时器 3 个和 Timer_B 定时器 1 个，按照每个寄存器配备的捕获&#x2F;比较器的个数分别命名为</p>
<p>​ Timer0_A（内有 5 个捕获比较器）</p>
<p>​ Timer1_A（3 个）</p>
<p>​ Timer2_A（3 个）</p>
<p>​ Timer0_B（7 个）</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">Timer_A 特性包括：</span><br><span class="line">带有<span class="number"> 4 </span>种操作模式的异步<span class="number"> 16 </span>位定时/计数器</span><br><span class="line">	时钟源可选择，可配置</span><br><span class="line">	可配置捕获/比较寄存器数多达<span class="number"> 7 </span>个</span><br><span class="line">	有 PWM 输出功能的可配置输出</span><br><span class="line">	异步输入和同步锁存</span><br><span class="line">	对 Timer_A 中断快速响应的中断向量寄存器</span><br></pre></td></tr></table></figure>

<p>定时器分为两种模式：比较、捕获</p>
<p>​ 比较：当 CAP&#x3D;0 时，选择比较模式。比较模式用来产生 PWM 输出信号或者特定的定时中 断。</p>
<p>​ 捕获：当 CAP&#x3D;1 时，选择捕获模式。捕获模式用来记录时间事件。它可用于速度计算或时间 测量。捕获输入 CCIxA 和 CCIxB 可以连接到外部管脚或者内部信号，由 CCISx 位选 择。CMx 位选择输入信号的上升沿、 下降沿或者上升沿和下降沿作为捕获沿。在所选 择的输入信号的触发沿时，产生捕获。</p>
<h3 id="1、比较"><a href="#1、比较" class="headerlink" title="1、比较"></a>1、比较</h3><p><img src="C:\Users\xiudi\AppData\Roaming\Typora\typora-user-images\image-20210614212838596.png" alt="image-20210614212838596"></p>
<p><img src="C:\Users\xiudi\AppData\Roaming\Typora\typora-user-images\image-20210614213053216.png" alt="image-20210614213053216"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">TA0CTL = TASSEL__SMCLK + MC__UP +ID__8 + TACLR; <span class="regexp">//</span>SMCLK时钟，上增，分频，使能</span><br><span class="line">TA0CCR0 = <span class="number">31250</span>*<span class="number">2</span>;								<span class="regexp">//</span>上限值</span><br><span class="line">TA0CCTL0 = CCIE;								<span class="regexp">//</span>比较器使能</span><br><span class="line">_EINT();										<span class="regexp">//</span>全部中断允许</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">比较——呼吸灯：</span><br><span class="line"><span class="comment">#include &lt;msp430.h&gt;</span></span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	WDTCTL = WDTPW | WDTHOLD;	<span class="regexp">//</span> stop watchdog timer</span><br><span class="line"></span><br><span class="line">	TA0CTL |= TASSEL_2;			<span class="regexp">//</span>调试定时器<span class="number">0</span>，时钟SMCKL，增减模式</span><br><span class="line">	TA0CTL |= MC_0 | MC_1;</span><br><span class="line">	TA0CCR0 = <span class="number">0</span>x00FF;</span><br><span class="line">	TA0CCR1 = <span class="number">0</span>x00FF;</span><br><span class="line"></span><br><span class="line">	TA0CCTL0 &amp;= ~CAP;			<span class="regexp">//</span>寄存器<span class="number">0</span>：比较模式</span><br><span class="line">	TA0CCTL1 &amp;= ~CAP;			<span class="regexp">//</span>寄存器<span class="number">1</span>：比较模式</span><br><span class="line">	TA0CCTL1 |= OUTMOD_6;		<span class="regexp">//</span>寄存器<span class="number">1</span>：捕获/比较 <span class="number">6</span></span><br><span class="line"></span><br><span class="line">	P1SEL |= BIT2;				<span class="regexp">//</span>P1.<span class="number">2</span>第二功能</span><br><span class="line">	P1DIR |= BIT2;				<span class="regexp">//</span>P1.<span class="number">2</span>输出</span><br><span class="line"></span><br><span class="line">	P1DIR |= BIT0;				<span class="regexp">//</span>P1.<span class="number">0</span>输出</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">for</span>(cnt = <span class="number">0</span>;cnt &lt; <span class="number">0</span>x00FF; cnt++)		<span class="regexp">//</span>用查询法实现呼吸灯</span><br><span class="line">	    &#123;</span><br><span class="line">	               TA0CCR1 =  cnt;</span><br><span class="line">	               __delay_cycles(<span class="number">5000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">for</span>(cnt = <span class="number">0</span>x00FF;cnt &gt; <span class="number">0</span>; cnt--)</span><br><span class="line">	    &#123;</span><br><span class="line">	               TA0CCR1 =  cnt;</span><br><span class="line">	               __delay_cycles(<span class="number">5000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、捕获"><a href="#2、捕获" class="headerlink" title="2、捕获"></a>2、捕获</h3><p><img src="C:\Users\xiudi\AppData\Roaming\Typora\typora-user-images\image-20210615181205852.png" alt="image-20210615181205852"></p>
<p><img src="C:\Users\xiudi\AppData\Roaming\Typora\typora-user-images\image-20210615181533212.png" alt="image-20210615181533212"></p>
<p>先设置总的定时器 Timer。</p>
<p>当 CM 不等于 0 时，为捕获模式，同时 CAP 也要为 1，相关引脚设为第二功能。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">TA0CTL |= TASSEL_2;		<span class="regexp">//</span>设置中断信号源为SMCLK</span><br><span class="line">   TA0CTL |= MC_1;			<span class="regexp">//</span>上数模式</span><br><span class="line">   TA0CCR0 = <span class="number">49999</span>;		<span class="regexp">//</span>数值设为<span class="number">49999</span></span><br><span class="line">   TA0CTL = TAIE;			<span class="regexp">//</span>允许启动</span><br><span class="line"></span><br><span class="line">   TA0CCTL1 |= CAP;		<span class="regexp">//</span>捕获模式</span><br><span class="line">   TA0CCTL1 |= CM_1;		<span class="regexp">//</span>上升沿捕获</span><br><span class="line">   TA0CCTL1 |= CCIS0;		<span class="regexp">//</span>参考信号源</span><br><span class="line">   P1SEL |= BIT2;			<span class="regexp">//</span>引脚设为第二功能</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>msp430</category>
      </categories>
      <tags>
        <tag>msp430笔记</tag>
      </tags>
  </entry>
</search>
